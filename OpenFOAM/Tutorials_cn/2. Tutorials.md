## 第2章 教程

在本章中，我们将详细描述一些 OpenFOAM 测试用例的设置、模拟和后处理过程，主要目的是向用户介绍运行 OpenFOAM 的基本过程。$ *FOAM* *_TUTORIALS*目录包含更多案例，这些案例展示了 OpenFOAM 提供的所有求解器和许多实用程序的使用。

在尝试运行教程之前，用户必须首先确保正确安装了 OpenFOAM。教程中的案例将复制到所谓的*运行中*目录，用户文件系统中的 OpenFOAM 项目目录 *$HOME/OpenFOAM/<USER>-9/run* 其中< *USER* >是帐户登录名，“9”是 OpenFOAM 版本号。*运行*目录由$ *FOAM* *_RUN*环境变量表示，使用户可以通过键入方便地检查其存在

```sh
	ls $FOAM_RUN
```

如果返回消息说不存在这样的目录，用户应该通过键入来创建目录

```sh
	mkdir -p $FOAM_RUN
```

教程案例描述了网格划分和预处理实用程序的使用、案例设置和运行 OpenFOAM 求解器以及使用*ParaView*进行后处理。

所有教程的副本都可以从教程中*获得*OpenFOAM 安装目录。教程根据流的类型组织到一组目录中，然后根据求解器组织到子目录中。例如，所有*simpleFoam*案例都存储在子目录*incompressible/simpleFoam*中，其中*incompressible* 表示流的类型。*用户可以根据需要将教程*目录中的案例复制到其本地*运行*目录中。例如，要运行*simpleFoam*求解器的*pitzDaily*教程案例，用户可以通过键入以下命令将其复制到*运行*目录：

```sh
    cd $FOAM_RUN
    cp -r $FOAM_TUTORIALS/incompressible/simpleFoam/pitzDaily .
```




## 2.1 盖驱动型腔流动



本教程将描述如何预处理、运行和后处理涉及二维正方形域中等温、不可压缩流动的案例。几何图形如图 [2.1](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-40111)所示，其中正方形的所有边界都是墙壁。![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user1x.png)顶壁以 1 m/s 的速度沿 -方向移动，而其他 3 个是静止的。最初，将假定流为层流并将使用*icoFoam在均匀网格上求解*层流、等温、不可压缩流动的求解器。在本教程的过程中，将研究增加的网格分辨率和对墙壁的网格分级的影响。最后，流动雷诺数将增加和*pisoFoam*求解器将用于湍流，等温，不可压缩流动。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user2x.png)

图 2.1：盖子驱动腔的几何形状。 

### 2.1.1 预处理

通过编辑案例文件在 OpenFOAM 中设置案例。用户应该选择一个编辑器来执行此操作，例如*emacs*、*vi*、*gedit*、*nedit*等*。*在 OpenFOAM 中编辑文件是可能的，因为 I/O 使用带有传达足够含义的关键字的字典格式用户。

正在模拟的案例涉及网格、场、属性、控制参数等数据。如第 [4.1](https://cfd.direct/openfoam/user-guide/v9-case-file-structure#x16-1220004.1)节所述，在 OpenFOAM 中，此数据存储在案例目录中的一组文件中，而不是像许多其他 CFD 软件包。案例目录具有适当的描述性名称。本教程包含一组位于$ *FOAM* *_TUTORIALS/incompressible/icoFoam/cavity*的案例，其中第一个案例简称为*cavity*。作为第一步，用户应该将*cavity*案例目录复制到他们的*运行*目录。

```sh
    cd $FOAM_RUN
    cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavity . 
    cd cavity
```

  

#### 2.1.1.1 网格生成

OpenFOAM 始终以 3 维笛卡尔坐标运行坐标系并且所有几何图形都是在 3 维中生成的。OpenFOAM 默认在 3 维中求解，但可以通过指定“特殊”*空边界*来指示在 2 维中求解，边界上的（第 3）维，不需要解。

*空腔*域由-平面![d = 0.1 米](https://cdn.cfd.direct/docs/user-guide-v9/img/user3x.png)中的边长的平方组成。最初将使用 20 x 20 单元的均匀网格。块结构如图 [2.2](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-60052)所示。![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user4x.png)![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user5x.png)



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user6x.png)

图 2.2：空腔网格的块结构。 

OpenFOAM 提供的网格生成器*blockMesh*根据输入字典*blockMeshDict中指定的描述生成网格*位于给定案例的*系统*（或*constant/多边形网格）目录中。*本案例的*blockMeshDict*条目如下：

```c++
/*––––––––––––––––––––––––––––––--*- C++ -*–––––––––––––––––––––––––––––––––-*\\
  =========                 |
  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\\\    /   O peration     | Website:  https://openfoam.org
    \\\\  /    A nd           | Version:  9
     \\\\/     M anipulation  |
\\*–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/
FoamFile
{
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

convertToMeters 0.1;

vertices
(
    (0 0 0)
    (1 0 0)
    (1 1 0)
    (0 1 0)
    (0 0 0.1)
    (1 0 0.1)
    (1 1 0.1)
    (0 1 0.1)
);

blocks
(
    hex (0 1 2 3 4 5 6 7) (20 20 1) simpleGrading (1 1 1)
);

edges
(
);

boundary
(
    movingWall
    {
        type wall;
        faces
        (
            (3 7 6 2)
        );
    }
    fixedWalls
    {
        type wall;
        faces
        (
            (0 4 7 3)
            (2 6 5 1)
            (1 5 4 0)
        );
    }
    frontAndBack
    {
        type empty;
        faces
        (
            (0 3 2 1)
            (4 5 6 7)
        );
    }
);

mergePatchPairs
(
);

// ************************************************************************* //
```



该文件首先包含横幅形式的标题信息（第 1-7 行），然后包含在*FoamFile*子字典中的文件信息，由大括号 ( { ... } ) 分隔。*对于手册的其余部分：*
为了清楚起见和节省空间，文件标题，包括横幅和*FoamFile*子字典，将从案例文件的逐字引用中删除

该文件首先指定块顶点的坐标; 然后它定义块（这里只有 1 个）来自顶点标签和其中的单元格数量；最后，它定义了边界面。鼓励用户参考第 [5.3](https://cfd.direct/openfoam/user-guide/v9-blockMesh#x26-1850005.3)节以了解*blockMeshDict*文件中条目的含义。

网格是通过在这个*blockMeshDict*上运行*blockMesh生成的*文件。在案例目录中，只需在终端中键入即可完成此操作：

 ```sh
     blockMesh
 ```



*blockMesh*的运行状态在终端窗口中报告。*blockMeshDict*文件中的任何错误都会被*blockMesh*拾取，并且生成的错误消息会将用户引导到文件中发生问题的行。在这个阶段应该没有错误信息。

#### 2.1.1.2 边界条件和初始条件



网格生成完成后，用户可以查看为这种情况设置的初始域。案例设置为在时间![t = 0](https://cdn.cfd.direct/docs/user-guide-v9/img/user7x.png) s 开始，因此初始域数据存储在 *cavity* 目录的*0*子目录中。*0*子目录包含 2 个文件，*p*和*U* *，*一个用于每个压力 ( p ) 和速度 ( U ) 域，其初始值和边界条件必须设置。让我们检查文件*p*:

```c++
dimensions      [0 2 -2 0 0 0 0];

internalField   uniform 0;

boundaryField
{
    movingWall
    {
        type            zeroGradient;
    }

    fixedWalls
    {
        type            zeroGradient;
    }

    frontAndBack
    {
        type            empty;
    }
}

// ************************************************************************* //
```



域数据文件中有 3 个主要条目：

- 大小

  指定场的尺寸，这里是*运动学*压力，*即* ![m2s- 2](https://cdn.cfd.direct/docs/user-guide-v9/img/user10x.png) （有关更多信息，请参见第 [4.2.6](https://cfd.direct/openfoam/user-guide/v9-basic-file-format#x17-1290004.2.6)节)；

- 内部场

  可以统一的内部场数据，由单个值描述；或nonuniform，其中必须指定场的所有值（有关更多信息，请参阅第 [4.2.8](https://cfd.direct/openfoam/user-guide/v9-basic-file-format#x17-1310004.2.8)节）；

- 边界场

  边界场数据，包括边界条件和所有边界面的数据（有关更多信息，请参见第 [4.2.8](https://cfd.direct/openfoam/user-guide/v9-basic-file-format#x17-1310004.2.8)节 ）。

对于这种情况下*腔体*，边界仅由壁组成，分为 2 个面，命名为：（1）fixedWalls，用于腔体的固定侧面和底部；(2) movingWall为型腔顶部的移动。作为墙壁，两者都被赋予了p的*zeroGradient*边界条件，这意味着“压力的法向梯度为零”。frontAndBack面代表 2D案例的正面和背面，因此必须设置为*空*。

在这种情况下，正如我们遇到的大多数情况一样，初始域设置为统一的。这里压力是运动学的，作为不可压缩的情况，它的绝对值是不相关的，所以为了方便设置为统一 0 。

*用户可以类似地检查0/U*文件中的速度场。尺寸是速度的预期尺寸，内部场初始化为均匀零，在速度的情况下，它必须由 3 个矢量分量表示，*即*均匀 (0 0 0)（更多信息请参见第 [4.2.5](https://cfd.direct/openfoam/user-guide/v9-basic-file-format#x17-1280004.2.5)节）。

速度的边界场需要与frontAndBack面相同的边界条件。其他面是墙壁：在fixedWalls上假设无滑移条件，因此无滑移条件。顶面在 x 方向以 1 m/s 的速度移动，因此需要一个带有*固定值*均匀( 1 0 0)的条件。

#### 2.1.1.3 物理性质

案例的物理属性存储在*constant*目录中的字典文件中。对于*icoFoam*在这种情况下，唯一必须指定的属性是从*transportProperties*字典中存储的运动粘度。用户可以通过打开*transportProperties*字典查看/编辑其条目来检查运动粘度设置是否正确。运动粘度的关键字是nu，希腊符号的语音标签![ν](https://cdn.cfd.direct/docs/user-guide-v9/img/user12x.png)，它在方程式中用它来表示。最初，此案例将使用雷诺数10来运行，其中雷诺数定义为：

| ![Re = d\|U-\|- ν](https://cdn.cfd.direct/docs/user-guide-v9/img/user13x.png) | (2.1) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

其中![d](https://cdn.cfd.direct/docs/user-guide-v9/img/user14x.png)和![|U |](https://cdn.cfd.direct/docs/user-guide-v9/img/user15x.png)分别是特征长度和速度，![ν](https://cdn.cfd.direct/docs/user-guide-v9/img/user16x.png)是运动粘度. 这里![d =](https://cdn.cfd.direct/docs/user-guide-v9/img/user17x.png) 0.1 m, ![|U |  =](https://cdn.cfd.direct/docs/user-guide-v9/img/user18x.png) 1 m/s，所以对于![回复 =](https://cdn.cfd.direct/docs/user-guide-v9/img/user19x.png) 10, ![ν =](https://cdn.cfd.direct/docs/user-guide-v9/img/user20x.png) 0.01 ![平方米 -1](https://cdn.cfd.direct/docs/user-guide-v9/img/user21x.png)。因此，运动粘度的正确文件条目如下所示：

```c++

nu              [0 2 -1 0 0 0 0] 0.01;


// ************************************************************************* //
```



#### 2.1.1.4 控制

*从controlDict*中读入与时间控制和解数据的读写有关的输入数据字典。用户应该查看这个文件；作为案例控制文件，它位于*系统*目录中。

必须设置运行的开始/停止时间和时间步长。OpenFOAM 在时间控制方面提供了极大的灵活性，这在第 [4.4](https://cfd.direct/openfoam/user-guide/v9-controlDict#x19-1410004.4)节中有详细描述。在本教程中，我们希望在 time 开始运行，![t = 0](https://cdn.cfd.direct/docs/user-guide-v9/img/user22x.png)这意味着 OpenFOAM 需要从名为*0*的目录中读取域数据——有关案例文件结构的更多信息，请参见第 [4.1节。](https://cfd.direct/openfoam/user-guide/v9-case-file-structure#x16-1220004.1)因此我们设置startFromstartTime的关键字然后指定开始时间关键字为 0。

对于结束时间，我们希望达到流体在腔体周围循环的稳态解。作为一般规则，流体应通过该域 10 次以达到层流的稳定状态。在这种情况下，由于没有入口或出口，流动不通过该区域，因此可以将结束时间设置为盖子穿过腔体十次所用的时间，*即*1 秒；事实上，事后看来，我们发现 0.5 s 就足够了，所以我们将采用这个值。要指定此结束时间，我们必须将stopAt关键字指定为endTime然后设置结束时间关键字为 0.5。

现在我们需要设置时间步长，由关键字deltaT表示。在运行*icoFoam*时实现时间精度和数值稳定性, 一个库朗数要求小于 1。一个单元格的 Courant 数定义为：

| ![Co = δt\|U-\|  δx](https://cdn.cfd.direct/docs/user-guide-v9/img/user23x.png) | (2.2) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

![δt](https://cdn.cfd.direct/docs/user-guide-v9/img/user24x.png)时间步长在哪里,![|U |](https://cdn.cfd.direct/docs/user-guide-v9/img/user25x.png)是通过该单元格的速度大小，![δx](https://cdn.cfd.direct/docs/user-guide-v9/img/user26x.png)是在速度方向上的单元格大小。流速在整个域中变化，我们必须确保![钴 < 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user27x.png)无处不在。因此，我们![δt](https://cdn.cfd.direct/docs/user-guide-v9/img/user28x.png)根据最坏的情况进行选择：对应于大流速和小单元尺寸的综合效应的*最大值。* ![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user29x.png)在这里，单元大小在整个域中是固定的，因此最大值![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user29x.png)将出现在速度接近 1 ![   -1 毫秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user31x.png)的盖子旁边。单元格大小为：

| ![δx = d-= 0.1 = 0.005 百万 20](https://cdn.cfd.direct/docs/user-guide-v9/img/user32x.png) | (2.3) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

因此，要在整个域中实现小于或等于 1 的 Courant 数，时间步长deltaT必须设置为小于或等于：

| ![     Co δx 1 × 0.005 δt = –––––– = –––––––––-= 0.005 s \|U \|  1](https://cdn.cfd.direct/docs/user-guide-v9/img/user33x.png) | (2.4) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

随着模拟的进行，我们希望以特定的时间间隔写入结果，以便稍后使用后处理包查看。写控制关键字提供了几个用于设置结果写入时间的选项；这里我们选择timeStep选项指定在writeInterval下指定值的每个![n](https://cdn.cfd.direct/docs/user-guide-v9/img/user34x.png)时间步写入结果![n](https://cdn.cfd.direct/docs/user-guide-v9/img/user34x.png)关键词。让我们决定我们希望在 0.1, 0.2,…, 0.5 s 的时间写出我们的结果。由于时间步长为 0.005 秒，因此我们需要在每 20 个时间步长输出结果，因此我们将writeInterval设置为 20。

OpenFOAM 会在每次写入一组数据 时创建一个*以当前时间命名*的新目录，*例如0.1 秒，*[详见 4.1](https://cfd.direct/openfoam/user-guide/v9-case-file-structure#x16-1220004.1)节。在*icoFoam*求解器中，它写出每个域的结果，U和p, 进入时间目录。对于这种情况，*controlDict*中的条目如下所示：

```c++

application     icoFoam;

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         0.5;

deltaT          0.005;

writeControl    timeStep;

writeInterval   20;

purgeWrite      0;

writeFormat     ascii;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable true;


// ************************************************************************* //
```



#### 2.1.1.5 离散化和线性求解器设置

*用户在系统*目录的*fvSchemes*字典中指定有限体积离散方案的选择。线性方程求解器和公差以及其他算法控制的规范在*fvSolution*字典中进行，类似地在*系统*目录中。用户可以自由查看这些字典，但我们不需要在此阶段讨论它们的所有条目，除了pRefCell和pRefValue在*fvSolution*字典的*PISO*子字典。在封闭的不可压缩系统（例如空腔）中，压力是相对的：压力范围与绝对值无关。在这种情况下，求解器通过pRefValue设置参考水平在单元格pRefCell中. 在这个例子中，两者都设置为 0。改变其中任何一个值都会改变绝对压力场，但当然不会改变相对压力或速度场。

### 2.1.2 查看网格

在运行案例之前，最好查看网格以检查是否有任何错误。网格在*ParaView*中查看，它是 OpenFOAM 提供的后处理工具。视*景* 通过执行*paraFoam可以方便地在 OpenFOAM 案例数据上启动后处理* 案例目录中的脚本。

任何*UNIX* / *Linux*可执行文件都可以通过两种方式运行：作为前台进程，*即*shell等待命令完成后再给出命令提示符的一种；作为后台进程，它允许 shell 在它仍在运行时接受其他命令。由于在终端运行其他命令时保持*ParaView 处于*打开状态很方便，我们将使用&运算符在后台启动它，方法是键入

 ```sh
 	paraFoam &
 ```



或者，它可以从另一个目录位置启动，带有一个可选的-case参数给出案例目录，*例如*

```sh
   paraFoam -case $FOAM_RUN/cavity &
```



这将启动*ParaView* 窗口，如图 [6.1](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2260011)所示。在*管道* *浏览器中*，用户可以看到*ParaView* 已经打开了cavity.OpenFOAM，即*空腔*案例的模块。**在单击** `Apply` **按钮**之前，用户需要从*Mesh Parts*中选择一些几何图形控制板。由于案例很小，通过选中*Mesh Parts*面板标题旁边的框来选择所有数据是最简单的，它会自动检查相应面板中的所有单个组件。然后，用户应单击*Apply*按钮将几何图形加载到*ParaView*中。

然后用户应该向下滚动到*显示*控制所选模块的视觉表示的面板。在*显示*面板中，用户应该执行以下操作，如图 [2.3](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-110213)所示：

1. 在着色部分中，选择纯色(Solid Color)；
2. 单击*编辑*（在着色中）并选择适当的颜色，*例如*黑色（用于白色背景）；
3. 从表示菜单中选择线框。背景颜色可以在*View Render*中设置 “*属性*”窗口中“*显示*”面板下方的面板。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user36x.png)

图 2.3：在*paraFoam*中查看网格。 

尤其是用户第一次启动*ParaView*时，**建议他们按照**[6.1.5](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2300006.1.5)节所述操作视图 。特别是，由于这是2D情况，建议*Camera Parallel Projection*在*View Render*面板底部附近被选中。

### 2.1.3 运行应用程序

与任何*UNIX* / *Linux*可执行文件一样，OpenFOAM 应用程序可以在前台或后台运行。在这种情况下，我们将运行*icoFoam*在前台。*icoFoam*求解器通过进入案例目录并键入

```sh
    icoFoam
```

在命令提示符下，或使用可选的-case参数给出案例目录，*例如*

```sh
    icoFoam -case $FOAM_RUN/cavity
```

作业的进度被写入终端窗口。它告诉用户当前时间、最大 Courant 数、所有域的初始和最终残差。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user37x.png)

图 2.4：显示腔体的压力等值线。 



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user38x.png)

图 2.5：*腔体*中的压力。 

### 2.1.4 后期处理

一旦将结果写入时间目录，就可以使用*paraFoam*查看它们。返回*paraFoam*窗口并选择*Properties*空腔面板。OpenFOAM案例模块。如果机箱模块的正确窗口面板似乎在任何时候都不存在，请确保：cavity.OpenFOAM以蓝色突出显示；*旁边的眼睛*按钮打开以显示图形已启用；

为了准备*paraFoam* 来显示感兴趣的数据，我们必须首先在所需的 0.5 s 运行时间加载数据。如果案例在*ParaView*打开时运行，时间目录中的输出数据将不会自动加载到*ParaView*中。要加载数据，用户应取消选中*缓存网格*并单击*刷新* *时间*在**顶部的**“*属性*”窗口（如有必要，向上滚动面板）。当时间数据将被加载到*ParaView*中。

为了在![t = 0.5](https://cdn.cfd.direct/docs/user-guide-v9/img/user39x.png) s 查看解决方案，用户可以使用VCR Controls或当前时间控件将当前时间更改为 0.5。它们位于*ParaView*窗口顶部的工具栏中 ，如图 [6.4](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2290074)所示。

#### 2.1.4.1 着色表面

要查看压力，用户应前往*显示屏*面板，因为它控制所选模块的视觉表示。要制作简单的压力图，用户应选择以下选项，如图 [2.4](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-120034)中详细描述的：

1. 从表示菜单中选择表面；
2. ![epsfig](https://cdn.cfd.direct/docs/user-guide-v9/img/user40x.png)在着色中选择
3. 单击*重新缩放*按钮将色阶设置为数据范围（如有必要）。

压力场应如图 [2.5](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-120045)所示，在腔体的左上方有一个低压区域，在腔体的右上方有一个高压区域。

使用点图标 ( ![epsfig](https://cdn.cfd.direct/docs/user-guide-v9/img/user41x.png))，压力场在每个单元格上进行插值，以提供连续的外观。相反，如果用户![epsfig](https://cdn.cfd.direct/docs/user-guide-v9/img/user42x.png)从“着色”菜单中选择单元格图标 ，则将为每个单元格分配一个压力值，这样每个单元格将由没有分级的单一颜色表示。

可以通过单击“活动变量控件”工具栏中的“*切换颜色图例* *可见性*”按钮或“*显示*”面板的“*着色*”部分中的“*显示*”按钮来添加颜色图例。图例可以通过鼠标拖放定位在图像窗口中。在Active Variable Controls工具栏或*Display*面板的*Coloring*面板中的*Edit*按钮打开*Color Map Editor*窗口，如图 [2.6](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-140116)所示，用户可以在其中设置色标和颜色的一系列属性滑钮。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user43x.png)

图 2.6：颜色映射编辑器。 

特别是，*ParaView* 默认使用蓝色到白色到红色的色阶，而不是更常见的蓝色到绿色到红色（彩虹）。因此，用户*第* *一次*执行*ParaView*时，他们可能希望更改色标。这可以通过在*色阶编辑器中*选择*选择预设*按钮（带有心形图标）来完成。CFD 的常规色标是*蓝色到红色彩虹*，仅当用户在搜索栏中键入名称或检查该栏右侧的齿轮时才会列出。

选择*Blue to Red Rainbow*并单击*Apply* and *Close*后，用户可以单击面板绝对底部的*Save as Default按钮（文件保存符号），这样**ParaView* 将始终采用这种类型的彩条。

*用户还可以通过单击编辑* *颜色图例属性*来编辑颜色图例属性，例如文本大小、字体选择和标尺编号格式在搜索栏的最右侧，如图 [2.6](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-140116)所示。

#### 2.1.4.2 切割平面（切片）

如果用户旋转图像，通过在图像窗口中按住鼠标左键并移动光标，他们可以看到他们现在已经通过压力为完整的几何表面着色。为了生成真正的二维等高线图，用户应首先创建一个切割平面或“切片”。在*Pipeline Browser*中突出显示cavity.OpenFOAM模块后，用户应该选择Slice从过滤器中过滤*ParaView*顶部菜单中的菜单（在某些系统上可在屏幕顶部访问）。切片_过滤器最初可以在Common子菜单，但一旦选择，它会**移至**最近子菜单，从Common中**消失**子菜单。切割平面应居中，![(0.05,0.05,0.005)](https://cdn.cfd.direct/docs/user-guide-v9/img/user44x.png)其法线应设置为![(0, 0,1)](https://cdn.cfd.direct/docs/user-guide-v9/img/user45x.png)（单击*Z 法线*按钮)。

#### 2.1.4.3 轮廓

生成切割平面后，可以通过应用轮廓过滤器创建轮廓。在*Pipeline Browser*中突出显示Slice模块，用户应该选择Contour筛选。在*Properties*面板中，用户应该从Contour By菜单中选择压力。在Isosurfaces下，用户可以使用减号按钮删除默认值，然后添加 10 个值的范围。如果着色是实心的或由域（*例如* 压力）显示，则可以使用线框表示来显示轮廓。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user46x.png)

图 2.7：字形过滤器 的属性面板。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user47x.png)

图 2.8：*腔体*中的速度。 

#### 2.1.4.4 矢量图

在我们开始绘制流速矢量之前，删除已创建的其他模块可能会很有用，*例如*使用上面描述的Slice和Contour过滤器。这些可以： 通过在*管道浏览器*中突出显示相关模块并在其各自的*属性*面板中单击*删除*来完全删除它们；或者，通过在*Pipeline Browser*中切换相关模块的*眼睛*按钮来禁用。

我们现在希望为每个单元格中心的速度生成一个矢量字形。我们首先需要将数据过滤到单元中心，如第 [6.1.7.1](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2360006.1.7.1)节所述。在*Pipeline Browser中突出显示*cavity.OpenFOAM模块后，用户应从Filter- >Alphabetical菜单中选择Cell Centers，然后单击*Apply*。

*在Pipeline Browser*中突出显示这些中心后，用户应该从Filter->Common菜单中选择Glyph 。*属性*窗口面板应如图 [2.7](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-160037)所示。这个过时的图像省略了方向阵列必须设置为U。

我们建议将流行的过滤器添加到过滤器->收藏夹菜单中。在生成的*属性*面板中，必须从矢量菜单中选择速度场U 。用户应将字形的Scale Array设置为No scale array，并将*Set Scale Factor*设置为 0.005。在Glyph Mode 下，用户应该选择*All Points*。

单击*Apply*时，字形出现，但可能是单一颜色，*例如* 白色。用户应该按照速度大小为字形着色，这通常是通过在*Display*面板中设置Color by U来控制的。用户还可以在Edit Color Map中选择*Show Color Legend*。输出如图 [2.8所示，其中](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-160048)*Color Legend*选择了大写 Times Roman 字体通过取消 *选择自动标签格式* 并在*标签格式*文本框中输入%-#6.2f将标题和标签指定为 2 个固定有效数字。背景颜色在视图设置的*常规*面板中设置为白色，如第 [6.1.5.1](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2310006.1.5.1)节所述。

请注意，在左右墙壁上，字形似乎表示流过墙壁。但是，很明显，虽然流向垂直于壁，但其大小为 0。这种稍微令人困惑的情况是由于*ParaView*在字形缩小且速度大小为 0时 选择将字形定向在 ![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user48x.png)-方向造成的.



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user49x.png)

图 2.9：Stream Tracer过滤器 的属性面板。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user50x.png)

图 2.10：*腔体*中的流线。 

#### 2.1.4.5 流线图

同样，在用户继续在*ParaView*中进行后期处理之前，他们应该禁用模块，例如上述矢量图的模块。我们现在希望绘制速度流线，如第 [6.1.8](https://cfd.direct/openfoam/user-guide/v9-paraview#x31-2370006.1.8)节所述。在*Pipeline Browser中突出显示*cavity.OpenFOAM模块后，用户应从Filter 菜单中选择Stream Tracer，然后单击*Apply*。*属性*窗口面板应如图 [2.9](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-170059)所示。种子点应沿*高分辨率*线源指定垂直穿过几何图形的中心，*即*从![(0.05, 0,0.005)](https://cdn.cfd.direct/docs/user-guide-v9/img/user51x.png)到![(0.05,0.1,0.005)](https://cdn.cfd.direct/docs/user-guide-v9/img/user52x.png)。对于本指南中的图像，我们使用：一个点*分辨率*为 21；*最大步长*为 0.5；*初始步长*为 0.2；和，整合 方向 BOTH。Runge-Kutta 4/5 *IntegratorType*与默认参数一起使用。

单击*应用*后，将生成跟踪器。然后，用户应从“Filter”菜单中选择“Tube”以生成高质量的流线图像。对于本报告中的图像，我们使用：*Num.* *侧面*6；*半径*0.0003；和，*半径因子*10。流管按速度大小着色。单击*应用*后，应生成图 [2.10中的图像。](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-1700610)

### 2.1.5 增加网格分辨率

网格分辨率现在将在每个方向上增加两倍。较粗网格的结果将映射到较细的网格上，用作问题的初始条件。然后将来自较细网格的解与来自较粗网格的解进行比较。

#### 2.1.5.1 使用现有案例创建新案例

我们现在希望创建一个名为*cavityFine*的新案例，它是从*cavity*创建的。因此，用户应该克隆*型腔*案例并编辑必要的文件。首先，用户应该通过键入进入*运行*目录

 ```sh
 	cd $FOAM_RUN
 ```

请注意，还有一个方便的别名，名为run，它重现了上面的命令，只需键入run即可将目录更改为$ *FOAM* *_RUN*。

可以通过创建一个新的案例目录并从*cavity*案例中复制相关目录来创建*cavityFine* 案例。

```sh
    mkdir cavityFine
    cp -r cavity/constant cavityFine
    cp -r cavity/system cavityFine
```

然后，用户可以通过切换到案例目录来准备运行新案例。

```sh
    cd cavityFine
```

#### 2.1.5.2 创建更精细的网格

我们现在希望通过使用*blockMesh*来增加网格中的单元数。用户应在编辑器中打开*系统*目录中的*blockMeshDict*文件并编辑块规范。块在块下的列表中指定关键词。块定义的语法在第 [5.3.1.3](https://cfd.direct/openfoam/user-guide/v9-blockMesh#x26-1890005.3.1.3)节中有完整描述；在这个阶段，知道下面的十六进制首先是块中的顶点列表，然后是每个方向上的单元数列表（或向量）就足够了。对于*空腔*情况，这最初设置为(20 20 1) 。用户现在应该将其更改为(40 40 1)并保存文件。然后应该像以前一样通过运行*blockMesh*创建新的细化网格。

#### 2.1.5.3 将粗网格结果映射到细网格

*mapFields*实用程序将与给定几何相关的一个或多个域映射到另一个几何的相应域。在我们的示例中，这些域被认为是“一致的”，因为源域和目标域的几何形状和边界类型或条件是相同的。在此示例中执行*mapFields*时，我们使用-consistent命令行选项。

*mapFields*映射的域数据是从*controlDict*中startFrom和startTime指定的时间目录中读取的目标案例，*即*结果被映射到**的** **案例。**在此示例中，我们希望将来*cavity*的较粗网格的最终结果映射到*cavityFine*中，所以在*controlDict*字典中的 0.5 目录的startTime应该设置为0.5s ， startFrom应该设置为startTime。

该案例已准备好运行*mapFields*。键入mapFields -help快速显示*mapFields*需要源案例目录作为参数。我们正在使用-consistent选项，因此该实用程序是从*cavityFine*目录中执行的

```sh
    mapFields -consistent ../cavity
```

该实用程序应运行并输出到终端，包括：

```sh
Source: ".." "cavity"
Target: "." "cavityFine"

Create databases as time

Source time: 0.5
Target time: 0.5

Create meshes

Source mesh size: 400   Target mesh size: 1600

Consistently creating and mapping fields for time 0.5

    interpolating p
    interpolating U

End
```

#### 2.1.5.4 控制调整

为了保持 Courant 数小于 1，如第 [2.1.1.4](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-90002.1.1.4)节所述，时间步现在必须减半，因为所有单元格的大小都减半了。因此deltaT应该在*controlDict*字典中设置为 0.0025 s。当前以固定数量的时间步长的间隔写出现场数据。在这里，我们演示如何指定以固定时间间隔输出的数据。在 controlDict 的*writeControl*关键字下，而不是使用timeStep按固定数量的时间步请求输出条目，可以使用runTime在写入结果之间指定固定量的运行时间入口。在这种情况下，用户应该每 0.1 指定一次输出，因此应该设置writeInterval到0.1和writeControl到runTime. 最后，由于该案例是从在粗网格上获得的解开始的，因此我们只需要运行一小段时间即可实现对稳态的合理收敛。因此endTime应设置为 0.7 s。确保这些设置正确，然后保存文件。

#### 2.1.5.5 将代码作为后台进程运行

用户应该体验将*icoFoam*作为后台进程运行，将终端输出重定向到可以稍后查看的*日志文件。*在*cavityFine*目录中，用户应该执行：

```sh
    icoFoam > log &
    cat log
```




#### 2.1.5.6 带有细化网格的矢量图

用户可以在*ParaView*中同时打开多个案例；本质上是因为每个新案例只是出现在*Pipeline Browser*中的另一个模块。在*ParaView*中打开新的 OpenFOAM 案例时存在不便，因为它希望案例数据存储在单个文件中，该文件具有能够建立格式的文件扩展名。但是，OpenFOAM 将案例数据存储在多个文件中，名称中没有扩展名，位于特定的目录结构中。ParaView*阅读*器模块的工作基础是，当以 OpenFOAM 格式打开案例数据时，它会传递一个带有*.OpenFOAM*扩展名的虚拟（空）文件，该文件位于案例目录中。*paraFoam*脚本会自动创建这个文件——因此，*cavity* case 模块被称为cavity.OpenFOAM。

如果用户希望直接从*ParaView*中打开第二个案例，他们需要创建这样一个虚拟文件。他们可以“手动”执行此操作，或者更简单地说，使用带有选项-touch的*paraFoam*脚本。对于cavityFine 示例，这涉及从案例目录执行：

```sh
   paraFoam -touch
```

现在可以通过从文件菜单中选择打开来将*cavityFine*案例加载到*ParaView*中，并导航到*cavityFine*目录，打开cavityFine.OpenFOAM。用户现在可以在*ParaView*中对细化网格的结果进行矢量图。通过同时为两种情况启用字形图像，可以将该图与*空腔情况进行比较。*



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user53x.png)

图 2.11：选择用于绘图的域。 

#### 2.1.5.7 绘制图表

用户可能希望通过提取速度的一些标量测量并沿通过域的线绘制二维图来可视化结果。OpenFOAM 非常适合这种数据操作。有许多实用程序可以进行专门的数据操作，而*postProcess*实用程序，包括广泛的通用后处理功能。可以通过键入以下内容列出*postProcess*中的函数：

```sh
    postProcess -list
```

components和mag函数提供了有用的速度标量度量。当components函数在 case 上执行时，*例如 ，*  *cavity*，它从每个时间目录中读取速度矢量场，并在相应的时间目录中写入标量场Ux、Uy和Uz ，表示速度的![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user54x.png)和![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user55x.png)分量![z](https://cdn.cfd.direct/docs/user-guide-v9/img/user56x.png)。

用户可以在*型腔*和*型腔精细*情况下使用组件功能运行*postProcess*。例如，对于*空腔*案例，用户应该进入*空腔*目录并执行*postProcess*，如下所示：

```sh
    cd $FOAM_RUN/cavity
    postProcess -func "components(U)"
```


各个组件可以在*ParaView*中绘制为图形。它快速、方便并且对标签和格式有相当好的控制，所以打印输出是一个相当好的标准。但是，为了生成用于发布的图表，用户可能更喜欢编写原始数据并使用专用的绘图工具（例如*gnuplot* 或*Grace/xmgr ）进行绘制*。为此，我们建议使用第 [6.3.2](https://cfd.direct/openfoam/user-guide/v9-graphs-monitoring#x33-2610006.3.2)节和第 [2.2.3](https://cfd.direct/openfoam/user-guide/v9-plateHole#x6-470002.2.3)节中描述的采样工具。*在开始绘图之前*，用户需要将新生成的Ux、Uy和Uz域加载到*ParaView 中*. 为此，用户应单击cavity.OpenFOAM模块的*Properties*面板顶部的*Refresh Times* ，这将导致新域加载到*ParaView*并出现在*Volume Fields*窗口中。确保选择了新域并应用了更改，*即*如有必要，再次单击*应用。**此外，如果在“**网格零件”*面板中选择了边界区域，则会在边界处错误地插值数据。因此用户应该*取消选择* *Mesh Parts*面板中的面，*即* movingWall , fixedWall和frontAndBack，并应用更改。

现在，为了在*ParaView*中显示图形， 用户应该选择感兴趣的模块，*例如* cavity.OpenFOAM并应用Plot Over Line从过滤器- >数据分析菜单中过滤。*这将在现有3D 视图*窗口下方或旁边打开一个新的*XY 图*窗口。创建了一个PlotOverLine模块，用户可以在其中指定*属性*面板中线的端点。在这个例子中，用户应该在*Point1*和*Point2*文本框中将线垂直放置在域中心的上方，*即*从![(0.05,0,0.005 )](https://cdn.cfd.direct/docs/user-guide-v9/img/user57x.png)到![(0.05,0.1,0.005)](https://cdn.cfd.direct/docs/user-guide-v9/img/user58x.png)。*分辨率*可以设置为 100 。

单击*Apply*后，会在*XY Plot*窗口中生成一个图形。在*显示*面板中，用户应将属性模式设置为点数据。可以为*X Axis Data选择*Use Data Array选项，采用arc _length选项，以便图形的 x 轴表示距型腔底部的距离。

用户可以在“*显示*”窗口的“*线系列”*面板中选择要显示的域。从要显示的标量场列表中可以看出，矢量场的大小和分量默认是可用的，*例如* 显示为U _X，因此无需使用components函数创建Ux 。尽管如此，用户应该取消选择除Ux（或U _x）之外的所有系列。所选系列的相邻列中的方形颜色框指示线条颜色。用户可以通过在该选择上双击鼠标来最轻松地对其进行编辑。

为了格式化图表，用户应该修改*Line Series*面板下方的设置，即Line Color、Line Thickness、Line Style、Marker  Style和Chart Axes。

用户也可以单击*XY 图*左上角上方的按钮之一。例如，第三个按钮允许用户控制*视图设置*，例如，用户可以在其中设置每个轴的标题和图例。此外，用户可以设置轴标题的字体、颜色和对齐方式，并有多个轴范围和线性或对数刻度标签选项。

图 [2.12](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-2601312)是使用*ParaView*生成的图表。用户可以根据自己的意愿生成图表。作为参考，图 [2.12](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-2601312)中的图表是使用以下轴选项生成的：标准类型的表示法；*指定选定的轴* *范围*；Sans Serif 12字体的标题。通过激活*启用线系列*，图形显示为一组点而不是一条线*显示*窗口中的按钮。注意：如果此按钮因“灰显”而显得不活动，则可以通过在*Line Series*面板中选择和取消选择变量集来使其处于活动状态。一旦*启用线系列*按钮被选中，线条样式和标记样式可以根据用户的喜好进行调整。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user59x.png)

图 2.12：在*paraFoam*中绘制图形。 

### 2.1.6 引入网格分级

在真解的形式与所选数值方案中假设的形式大不相同的区域中，任何解的误差都会更加明显。例如，如果真解本身在形式上是线性的，则基于单元上变量的线性变化的数值方案只能生成精确解。在真解偏离线性形式最大的区域，*即*梯度变化最大的区域，误差最大。误差随着单元格大小而减小。

在设置任何问题之前，对解决方案的形式有一个直观的了解是很有用的。然后可以预测误差最大的位置，并对网格进行分级，以便最小的单元在这些区域中。在*空腔*示例中，可以预期在壁附近的速度变化很大，因此在本教程的这一部分中，网格将在该区域被分级为更小。通过使用相同数量的单元，可以在不显着增加计算成本的情况下实现更高的精度。

![20 × 20](https://cdn.cfd.direct/docs/user-guide-v9/img/user60x.png)将为盖子驱动的空腔问题创建 一个朝向墙壁分级的单元网格，然后将第[2.1.5.2](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-210002.1.5.2)节的更精细网格的结果映射到分级网格上以用作初始条件。分级网格的结果将与先前网格的结果进行比较。由于对*blockMeshDict*字典的更改相当大，因此本部分教程使用的 case，*cavityGrade*，在$ *FOAM* *_TUTORIALS/incompressible/icoFoam/cavity*目录中提供。用户应将*cavityGrade*案例复制到*运行*目录中，然后按照以下步骤操作。

#### 2.1.6.1 创建渐变网格

网格现在需要 4 个块，因为在域的左侧和右侧以及顶部和底部需要不同的网格分级。该网格的块结构如图 [2.13](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-2800113)所示。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user61x.png)

图 2.13： 型腔分级网格的块结构（块编号圈出）。 

用户可以查看*blockMeshDict*文件在*cavityGrade*的*系统*子目录中；为完整起见， *blockMeshDict*文件的关键元素也复制如下。现在每个块在![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user63x.png)和![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user64x.png)方向上都有![10](https://cdn.cfd.direct/docs/user-guide-v9/img/user62x.png)单元格，最大和最小单元格之间的比率为![2](https://cdn.cfd.direct/docs/user-guide-v9/img/user65x.png)。

```c++
convertToMeters 0.1;

vertices
(
    (0 0 0)
    (0.5 0 0)
    (1 0 0)
    (0 0.5 0)
    (0.5 0.5 0)
    (1 0.5 0)
    (0 1 0)
    (0.5 1 0)
    (1 1 0)
    (0 0 0.1)
    (0.5 0 0.1)
    (1 0 0.1)
    (0 0.5 0.1)
    (0.5 0.5 0.1)
    (1 0.5 0.1)
    (0 1 0.1)
    (0.5 1 0.1)
    (1 1 0.1)
);

blocks
(
    hex (0 1 4 3 9 10 13 12) (10 10 1) simpleGrading (2 2 1)
    hex (1 2 5 4 10 11 14 13) (10 10 1) simpleGrading (0.5 2 1)
    hex (3 4 7 6 12 13 16 15) (10 10 1) simpleGrading (2 0.5 1)
    hex (4 5 8 7 13 14 17 16) (10 10 1) simpleGrading (0.5 0.5 1)
);

edges
(
);

boundary
(
    movingWall
    {
        type wall;
        faces
        (
            (6 15 16 7)
            (7 16 17 8)
        );
    }
    fixedWalls
    {
        type wall;
        faces
        (
            (3 12 15 6)
            (0 9 12 3)
            (0 1 10 9)
            (1 2 11 10)
            (2 5 14 11)
            (5 8 17 14)
        );
    }
    frontAndBack
    {
        type empty;
        faces
        (
            (0 3 4 1)
            (1 4 5 2)
            (3 6 7 4)
            (4 7 8 5)
            (9 10 13 12)
            (10 11 14 13)
            (12 13 16 15)
            (13 14 17 16)
        );
    }
);

mergePatchPairs
(
);

// ************************************************************************* //
```

一旦熟悉了本案例的*blockMeshDict*文件，用户就可以从命令行执行*blockMesh*。如第 [2.1.2](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-110002.1.2)节所述，可以像使用*paraFoam*之前一样查看分级网格。

#### 2.1.6.2 改变时间和时间步长

最高的速度和最小的单元在盖子旁边，因此最高的 Courant 数将在盖子旁边生成，原因在第 [2.1.1.4](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-90002.1.1.4)节中给出。因此，估计盖子旁边的单元格的大小以计算这种情况下的适当时间步长很有用。

当使用非均匀网格分级时，*blockMesh*使用几何级数计算单元格大小。沿着长度![l](https://cdn.cfd.direct/docs/user-guide-v9/img/user66x.png)，如果![n](https://cdn.cfd.direct/docs/user-guide-v9/img/user67x.png)请求的单元格在最后一个单元格和第一个单元格之间的比率为![R](https://cdn.cfd.direct/docs/user-guide-v9/img/user68x.png) ，则最小单元格的大小 ，![δxs](https://cdn.cfd.direct/docs/user-guide-v9/img/user69x.png)由下式给出：

| ![        r - 1 δxs = l––––––- αr - 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user70x.png) | (2.5) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

其中![r](https://cdn.cfd.direct/docs/user-guide-v9/img/user71x.png)是一个单元格大小与下一个单元格大小之间的比率，由下式给出：

| ![        1 r = R n--1](https://cdn.cfd.direct/docs/user-guide-v9/img/user72x.png) | (2.6) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

和

| ![    { R 代表 R > 1，α = 1 - r- n + r- 1 代表 R < 1。](https://cdn.cfd.direct/docs/user-guide-v9/img/user73x.png) | (2.7) |
| ------------------------------------------------------------ | ----- |
|                                                              |       |

对于*cavityGrade*情况，块中每个方向的单元数为10，最大和最小单元之间的比率为![2](https://cdn.cfd.direct/docs/user-guide-v9/img/user74x.png)，块的高度和宽度为0.05 ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user75x.png)。因此最小的单元长度是 3.45 ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user75x.png)![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user75x.png)。根据公式 [2.2](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-9016r2)，时间步长应小于 3.45![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user78x.png)![s](https://cdn.cfd.direct/docs/user-guide-v9/img/user79x.png) 以保持 Courant 小于 1。为确保以方便的时间间隔写出结果，时间步长deltaT应减少到 2.5![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user78x.png)![s](https://cdn.cfd.direct/docs/user-guide-v9/img/user79x.png) 并将writeInterval设置为 40，以便结果每 0.1 秒写入一次。这些设置可以在*cavityGrade/system/controlDict*文件中查看。

startTime需要设置为*casecavityFine*的最终条件，*即* 0.7。由于*cavity*和*cavityFine*在规定的运行时间内收敛得很好，我们可以将*casecavityGrade* 的运行时间设置为0.1 s，*即* endTime应该是0.8。

#### 2.1.6.3 映射域

第一的，

与第 [2.1.5.3](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-220002.1.5.3)节一样，使用*mapFields*将 casecavityFine 的最终结果映射到*casecavityGrade*的网格*上*。在*cavityGrade*目录中，通过以下方式执行*mapFields*：

 ```sh
      mapFields -consistent ../cavityFine
 ```

现在从案例目录运行*icoFoam*并监控运行时间信息。查看此案例的收敛结果，并使用之前在第 [2.1.5.6](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-250002.1.5.6)节和第 [2.1.5.7](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-260002.1.5.7)节中描述的后处理工具与其他结果进行比较。

### 2.1.7 增加雷诺数

到目前为止解决的案例的雷诺数为 10。这是非常低的，并且可以快速得到稳定的解决方案，在空腔的底角只有小的二次涡流。我们现在将雷诺数增加到 100，此时解决方案需要明显更长的时间才能收敛。最初将使用*腔体*中最粗的网格。用户应该克隆*空腔*案例并将其命名为*cavityHighRe*。不是像前面描述的那样*复制单个目录（* *system*，*constant*等）， *foamCloneCase* 可以使用，一步复制相关目录。默认情况下会复制*0*时间目录，但这里用户可以使用-latestTime选项复制最新时间目录*0.5*，它可以用作我们模拟的初始域数据。该示例还使用*运行*别名作为切换到*运行*目录的快速方法。

```sh
    run
    foamCloneCase -latestTime cavity cavityHighRe
    cd cavityHighRe
```

#### 2.1.7.1 预处理

进入*cavityHighRe*案例并编辑*constant*目录中的*transportProperties*字典。由于雷诺数需要增加 10 倍，因此将运动粘度降低 10 倍 ，*即* ![1 × 10- 3](https://cdn.cfd.direct/docs/user-guide-v9/img/user82x.png) ![平方米 -1](https://cdn.cfd.direct/docs/user-guide-v9/img/user83x.png)。我们现在通过重新启动来运行这个案例*从模腔*案例运行结束时的解决方案。为此，我们可以使用将startFrom关键字设置为latestTime的选项这样*icoFoam*将存储在与最近时间对应的目录中的值作为其初始数据，*即* *0.5*。endTime应设置为 2 秒。

#### 2.1.7.2 运行代码

从案例目录中为此案例运行*icoFoam并查看运行时信息。*在后台运行作业时，以下 UNIX 命令可能很有用：

- **nohup**

  使命令在发出命令的用户注销后继续运行；

- **nice**

  更改内核调度程序中作业的优先级；niceness -20 是最高优先级，19 是最低优先级。

这很有用，例如，如果用户希望设置一个在远程机器上运行的案例并且不希望对其进行大量监视，在这种情况下，他们可能希望在机器上给它低优先级。在这种情况下，nohup命令允许用户退出他/她正在运行的远程机器并继续运行作业，而nice可以将优先级设置为 19。对于我们感兴趣的情况，我们可以在此执行命令方式如下：

```sh
    nohup nice -n 19 icoFoam > log &
    cat log
```


在之前的运行中，您可能已经注意到*icoFoam 很快*停止求解速度U，但继续求解压力p的时间更长，或者直到运行结束。在实践中，一旦*icoFoam*停止求解U并且p的初始残差小于*fvSolution*字典中设置的容差（通常为![10-6](https://cdn.cfd.direct/docs/user-guide-v9/img/user84x.png)），则运行已有效收敛并且可以在将域数据写入时间目录后停止。例如，在收敛时， *cavityHighRe*情况下运行的*日志*文件样本如下所示，其中速度在 1.395 秒后已经收敛，初始压力残差很小；No Iterations 0表示U的解已停止：

```sh
Time = 1.43

Courant Number mean: 0.221921 max: 0.839902
smoothSolver:  Solving for Ux, Initial residual = 8.733e-06, Final residual = 8.733e-06, No Iterations 0
smoothSolver:  Solving for Uy, Initial residual = 9.896e-06, Final residual = 9.896e-06, No Iterations 0
DICPCG:  Solving for p, Initial residual = 3.675e-06, Final residual = 8.629e-07, No Iterations 4
time step continuity errors : sum local = 6.579e-09, global = -6.667e-19, cumulative = -6.2539e-18
DICPCG:  Solving for p, Initial residual = 2.608e-06, Final residual = 7.925e-07, No Iterations 3
time step continuity errors : sum local = 6.261e-09, global = -1.029e-18, cumulative = -7.28374e-18
ExecutionTime = 0.37 s  ClockTime = 0 s

Time = 1.435

Courant Number mean: 0.221923 max: 0.839903
smoothSolver:  Solving for Ux, Initial residual = 8.539e-06, Final residual = 8.539e-06, No Iterations 0
smoothSolver:  Solving for Uy, Initial residual = 9.714e-06, Final residual = 9.714e-06, No Iterations 0
DICPCG:  Solving for p, Initial residual = 4.022e-06, Final residual = 9.896e-07, No Iterations 3
time step continuity errors : sum local = 8.151e-09, global = 5.336e-19, cumulative = -6.75012e-18
DICPCG:  Solving for p, Initial residual = 2.388e-06, Final residual = 8.445e-07, No Iterations 3
time step continuity errors : sum local = 7.487e-09, global = -4.427e-19, cumulative = -7.19283e-18
ExecutionTime = 0.37 s  ClockTime = 0 s
```

### 2.1.8 高雷诺数流 ==?此处?==

*在paraFoam*中查看结果并显示速度矢量。拐角处的次级涡流的尺寸增加了。然后，用户可以通过降低粘度来进一步增加雷诺数，然后重新运行该案例。涡流的数量增加，因此它们周围的网格分辨率将需要增加，以解决更复杂的流动模式。此外，随着雷诺数的增加，收敛时间也会增加。用户应监控残差并相应地延长endTime以确保收敛。

随着流动进入湍流状态，增加空间和时间分辨率的需要变得不切实际，在那里也可能出现溶液稳定性的问题。当然，很多工程问题的雷诺数都很高，直接解决湍流行为的巨大成本是不可行的。取而代之的是雷诺平均模拟 (RAS) 湍流模型用于求解平均流动行为并计算波动的统计数据。本教程将使用具有壁面函数的标准![k - ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user85x.png)模型来求解雷诺数为![104](https://cdn.cfd.direct/docs/user-guide-v9/img/user86x.png). 解决了两个额外的变量：![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user87x.png)，湍流能量; 和, ![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user88x.png), 湍流耗散率. 湍流的附加方程和模型被实现到称为*pisoFoam*的 OpenFOAM 求解器中。

#### 2.1.8.1 预处理

回到运行目录，复制$ *FOAM* *_RUN/tutorials/incompressible/pisoFoam/RAS目录中的**型腔*案例（注意：pisoFoam/RAS目录），将其重命名为*cavityRAS*以避免与现有的*型腔*教程冲突。进入新的案例目录。

```sh
    run
    cp -r $FOAM_TUTORIALS/incompressible/pisoFoam/RAS/cavity cavityRAS
    cd cavityRAS
```

像以前一样通过运行*blockMesh*来生成网格。当使用具有壁面函数的标准模型时，不需要对壁面进行网格分级，![k - ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user89x.png)因为近壁面单元中的流动是模拟的，而不是必须求解。

OpenFOAM 中提供了一系列壁函数模型，它们作为边界条件应用于各个面。这使得不同的壁函数模型能够应用于不同的壁区域。壁函数模型的选择是通过*0/nut*文件![νt](https://cdn.cfd.direct/docs/user-guide-v9/img/user90x.png)中的湍流粘度域指定的：

```c++

dimensions      [0 2 -1 0 0 0 0];

internalField   uniform 0;

boundaryField
{
    movingWall
    {
        type            nutkWallFunction;
        value           uniform 0;
    }
    fixedWalls
    {
        type            nutkWallFunction;
        value           uniform 0;
    }
    frontAndBack
    {
        type            empty;
    }
}


// ************************************************************************* //
```

此案例使用标准墙函数，由movingWall和fixedWalls面上的nutWallFunction类型指定。其他壁面函数模型包括粗糙壁面函数，通过nutRoughWallFunction关键字指定。

![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user87x.png)用户现在应该打开和![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user92x.png)（*0/k*和*0/epsilon* ）的域文件并检查它们的边界条件。对于壁边界条件,![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user92x.png)被分配一个*epsilonWallFunction*边界条件，一个*kqRwallFunction*边界条件被分配给![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user94x.png)。后者是一种通用边界条件，可应用于任何具有湍流动能类型的场，例如*或* 雷诺应力。和的初始值是使用估计的速度波动分量和湍流长度尺度设置的![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user94x.png)![q](https://cdn.cfd.direct/docs/user-guide-v9/img/user96x.png)![R](https://cdn.cfd.direct/docs/user-guide-v9/img/user97x.png)![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user98x.png)![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user99x.png)![U'](https://cdn.cfd.direct/docs/user-guide-v9/img/user100x.png), ![l](https://cdn.cfd.direct/docs/user-guide-v9/img/user101x.png). ![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user102x.png)并![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user103x.png)根据这些参数定义如下：

![图片](https://cdn.cfd.direct/docs/user-guide-v9/img/user104x.png)

其中![Cμ](https://cdn.cfd.direct/docs/user-guide-v9/img/user105x.png)是![k - ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user106x.png)模型的常数，等于 0.09。对于笛卡尔坐标系，![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user107x.png)由下式给出：

| ![k = 1-(U′ 2 + U′ 2+ U′ 2) 2 xyz](https://cdn.cfd.direct/docs/user-guide-v9/img/user108x.png) | (2.10) |
| ------------------------------------------------------------ | ------ |
|                                                              |        |

其中![' 2 Ux](https://cdn.cfd.direct/docs/user-guide-v9/img/user109x.png),![  ' 2 U y](https://cdn.cfd.direct/docs/user-guide-v9/img/user110x.png)和分别是,和方向![  ′ 2 乌兹](https://cdn.cfd.direct/docs/user-guide-v9/img/user111x.png)的速度波动分量。让我们假设初始湍流是各向同性的，*即* 和 等于盖子速度的 5%，并且，等于盒子宽度的 5%，即 0.1 ，那么和由下式给出：![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user112x.png)![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user113x.png)![z](https://cdn.cfd.direct/docs/user-guide-v9/img/user114x.png) ![Ux′ 2= U′y 2= U′z 2](https://cdn.cfd.direct/docs/user-guide-v9/img/user115x.png)![l](https://cdn.cfd.direct/docs/user-guide-v9/img/user116x.png)![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user117x.png)![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user118x.png)![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user119x.png)

![图片](https://cdn.cfd.direct/docs/user-guide-v9/img/user120x.png)

![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user118x.png)这些构成和的初始条件![ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user122x.png)。和的初始条件分别为![ü](https://cdn.cfd.direct/docs/user-guide-v9/img/user123x.png)和0。![p](https://cdn.cfd.direct/docs/user-guide-v9/img/user124x.png)![(0,0,0)](https://cdn.cfd.direct/docs/user-guide-v9/img/user125x.png)

湍流建模包括 OpenFOAM 中提供的一系列方法，*例如* RAS 或大涡模拟 (LES)。湍流建模方法的选择可以在运行时通过SimulationType进行选择*动量传输*中的关键字字典（称为*turbulenceProperties*在 OpenFOAM v8 之前）。*用户可以在constant*目录下查看这个文件：

```c++

simulationType  RAS;

RAS
{
    model           kEpsilon;

    turbulence      on;

    printCoeffs     on;
}

// ************************************************************************* //
```

模拟类型的选项是层流的, RAS和LES. 在这种情况下选择 RAS，RAS 建模的选择在RAS子词典中指定。湍流模型由模型条目从第[7.2.1.1](https://cfd.direct/openfoam/user-guide/v9-turbulence#x37-2790007.2.1.1)节中列出的可用模型的长列表中选择 。应选择kEpsilon模型，即标准![k - ε](https://cdn.cfd.direct/docs/user-guide-v9/img/user126x.png)模型；用户还应确保打开湍流计算。

每个湍流模型的系数以一组默认值存储在各自的代码中。设置名为printCoeffs的可选开关 当模型在运行时被调用时，on将使默认值打印到标准输出，*即 终端。*系数被打印为一个子字典，其名称是模型名称的名称，附加单词Coeffs，*例如* kEpsilonCoeffs在kEpsilon模型的情况下。模型的系数，*例如* kEpsilon，可以通过选择性地在RAS子字典中包括（复制和粘贴）该子字典并相应地调整值来修改。

用户接下来应该在*transportProperties中设置层流运动粘度*字典。为了达到雷诺数![104](https://cdn.cfd.direct/docs/user-guide-v9/img/user127x.png), 运动粘度[根据公式2.1](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-8006r1)![10- 5](https://cdn.cfd.direct/docs/user-guide-v9/img/user128x.png) ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user129x.png) 中给出的雷诺数定义，需要 of 。

最后，用户应该在*controlDict中设置*startTime、stopTime、deltaT和writeInterval. 将deltaT设置为 0.005 s 以满足 Courant 数限制，并将endTime设置为 10 s。

#### 2.1.8.2 运行代码

通过进入案例目录并在终端中输入“ pisoFoam ”来执行*pisoFoam*。在这种情况下，在粘度较低的情况下，移动盖子旁边的边界层非常薄，盖子旁边的细胞相对较大，因此它们中心的速度远小于盖子速度。事实上，在 100 个时间步之后，很明显，与盖子相邻的单元中的速度达到了大约 0.2 的上限， 因此最大 Courant 数不会超过 0.2。通过将时间步长增加到 Courant 数更接近 1 的水平来增加求解时间是明智的。因此将deltaT重置为 0.02 s，在这种情况下，将startFrom设置为![≈](https://cdn.cfd.direct/docs/user-guide-v9/img/user130x.png)![毫秒 -1](https://cdn.cfd.direct/docs/user-guide-v9/img/user131x.png)最新时间。这指示*pisoFoam*从最新时间目录读取开始数据，*即* *10.0*。endTime应设置为 20 s，因为运行收敛速度比层流情况慢很多。像以前一样重新开始运行并监视解决方案的收敛性。随着解的进行，查看连续时间步的结果，以查看解是否收敛到稳态或可能达到某些周期性振荡状态。在后一种情况下，收敛可能永远不会发生，但这并不意味着结果不准确。

### 2.1.9 更改外壳几何形状

用户可能希望更改案例的几何形状并执行新的模拟。保留部分或全部原始解作为新模拟的起始条件可能很有用。这有点复杂，因为原始解决方案的域与新案例的域不一致。然而*mapFields*实用程序可以映射在几何或边界类型或两者方面不一致的域。

作为示例，让我们从用户*运行目录中的**教程目录中复制**cavityClipped*案例，并更改为*cavityClipped*目录：

```sh
    run
    cp -r $FOAM_TUTORIALS/incompressible/icoFoam/cavity/cavityClipped . 
    cd cavityClipped
```

*根据下面的blockMeshDict* ，该案例由标准的*腔*![0.04 米](https://cdn.cfd.direct/docs/user-guide-v9/img/user132x.png)几何形状组成，但从腔的右下角移除了一个正方形的长度：

```c++
convertToMeters 0.1;

vertices
(
    (0 0 0)
    (0.6 0 0)
    (0 0.4 0)
    (0.6 0.4 0)
    (1 0.4 0)
    (0 1 0)
    (0.6 1 0)
    (1 1 0)

    (0 0 0.1)
    (0.6 0 0.1)
    (0 0.4 0.1)
    (0.6 0.4 0.1)
    (1 0.4 0.1)
    (0 1 0.1)
    (0.6 1 0.1)
    (1 1 0.1)

);

blocks
(
    hex (0 1 3 2 8 9 11 10) (12 8 1) simpleGrading (1 1 1)
    hex (2 3 6 5 10 11 14 13) (12 12 1) simpleGrading (1 1 1)
    hex (3 4 7 6 11 12 15 14) (8 12 1) simpleGrading (1 1 1)
);

edges
(
);

boundary
(
    lid
    {
        type wall;
        faces
        (
            (5 13 14 6)
            (6 14 15 7)
        );
    }
    fixedWalls
    {
        type wall;
        faces
        (
            (0 8 10 2)
            (2 10 13 5)
            (7 15 12 4)
            (4 12 11 3)
            (3 11 9 1)
            (1 9 8 0)
        );
    }
    frontAndBack
    {
        type empty;
        faces
        (
            (0 2 3 1)
            (2 5 6 3)
            (3 6 7 4)
            (8 9 11 10)
            (10 11 14 13)
            (11 12 15 14)
        );
    }
);

mergePatchPairs
(
);

// ************************************************************************* //
```

*使用blockMesh*生成网格。与之前的空腔情况一样，相应地设置面。为了清楚地描述场映射过程，上壁贴片被重命名为lid，以前是原始*空腔的*movingWall贴片。

在不一致的映射中，不能保证所有域数据都可以从源案例映射。其余数据必须来自目标案例本身的现场文件。因此，在映射发生之前，域数据必须存在于目标案例的时间目录中。在*cavityClipped*情况下，映射设置为在时间0.5 s 发生，因为在*controlDict中*startTime设置为0.5 s 。因此，用户需要将初始域数据复制到该目录，*例如*从时间 0 开始：

```sh
    cp -r 0 0.5
```

在映射数据之前，用户应该在 0.5 秒时查看几何和域。

现在我们希望将来自*空腔的速度和压力场映射到空腔**Clipped*的新场上。由于映射不一致，我们需要编辑*mapFieldsDict*字典，位于*系统*目录中。该字典包含 2 个关键字条目：patchMap和cutPatches。patchMap列表包含从源域到目标域的面映射。如果用户希望目标域中的面从源域中的相应面继承值，则使用它。在*cavityClipped*中，我们希望从movingWall继承盖子面上的边界值在*空腔中*，所以我们必须将patchMap设置为：

```c++
    patchMap
    (
        lid movingWall
    );
```


![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user133x.png)

图 2.14：映射到*cavityClipped上的**空腔*解速度场。 



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user134x.png)

图 2.15：速度场的*空腔剪切*解。 

cutPatches列表包含目标面的名称，其值将从源内部域映射，目标面通过该域进行剪切。在这种情况下，fixedWalls面是无*滑移*条件，因此内部值不能插入到面中。因此，cuttingPatches列表可以简单地为空：

```c++
    cuttingPatches
    (
    );
```

如果用户确实希望将源案例的内部值插入到目标案例中的fixedWalls面中，则需要在面上指定一个*fixedValue*边界条件，然后可以在映射过程中覆盖其值；然后，fixedWalls面需要包含在cutPatches列表中。

用户应该从*cavityClipped*目录中运行*mapFields ：*

```sh
    mapFields ../cavity
```

用户可以查看映射的域，如图 [2.14](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-3716114)所示。正如我们预期的那样，fixedWalls面没有从源案例中继承值。然后，用户可以使用*icoFoam*运行案例。

### 2.1.10 对修改后的几何图形进行后处理

可以正常生成案例的速度字形，首先在时间 0.5 秒，然后在时间 0.6 秒，以比较初始和最终解决方案。此外，我们提供了一个几何轮廓，需要小心为 2D 案例生成。用户应从Filter菜单中选择Extract Block，并在*Parameter*面板中突出显示感兴趣的面，即*lid*和*fixedWalls*。单击“*应用*”后，可以通过在“*显示”*面板中选择“线框”来显示这些几何项目。图 [2.15](https://cfd.direct/openfoam/user-guide/v9-cavity/#x5-3716215)以黑色显示面，并显示在修改后的几何图形的底角形成的涡流。



## 2.2 带孔板的应力分析



本教程描述了如何对中心有圆孔的方形板上的线弹性稳态应力分析进行预处理、运行和后处理。板尺寸为：边长 4![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user135x.png) 和半径![R =](https://cdn.cfd.direct/docs/user-guide-v9/img/user136x.png) 0.5 ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user135x.png)。[如图2.16](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-3900316) 所示，它在其左右面上 加载了![σ =](https://cdn.cfd.direct/docs/user-guide-v9/img/user138x.png) 10 的均匀牵引力。[可以为这个几何图形识别两个对称平面，因此解域只需要覆盖几何图形的四分之一，如图2.16](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-3900316)中的阴影区域所示 。![ķ](https://cdn.cfd.direct/docs/user-guide-v9/img/user139x.png)![帕](https://cdn.cfd.direct/docs/user-guide-v9/img/user140x.png)



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user141x.png)

图 2.16：带孔板的几何形状。 

这个问题可以近似为二维的，因为载荷施加在板的平面上。在笛卡尔坐标系中，关于三维结构的行为有两个可能的假设： (1) 平面应力条件，其中假定作用在二维平面之外的应力分量可以忽略不计；(2) 平面应变条件，其中假设二维平面外的应变分量可以忽略不计。平面应力条件适用于在这种情况下第三维很薄的实体；平面应变条件适用于第三维较厚的实体。

存在用于加载具有圆孔的无限大薄板的解析解。垂直于对称垂直面的应力的解是

| ![           ( ( ) { R2 3R4 σ 1 + 2y2-+ 2y4- 对于 \|y\| ≥ R (σxx)x=0 = ( 0 对于 \|y\| < R](https://cdn.cfd.direct/docs/user-guide-v9/img/user142x.png) | (2.14) |
| ------------------------------------------------------------ | ------ |
|                                                              |        |

模拟结果将与此解决方案进行比较。在教程结束时，用户可以： 调查解对网格分辨率和网格分级的敏感性；并且，与孔相比，增加板的尺寸以尝试估计将无限板的解析解与有限板的该问题的解进行比较时的误差。

### 2.2.1 网格生成

该域由四个块组成，其中一些具有弧形边缘。平面内部分网格的块结构![x - y](https://cdn.cfd.direct/docs/user-guide-v9/img/user143x.png)如图 [2.17](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-4000117)所示。正如第 [2.1.1.1](https://cfd.direct/openfoam/user-guide/v9-cavity#x5-60002.1.1.1)节中已经提到的，所有几何图形在 OpenFOAM 中都是在 3 维中生成的，即使情况是作为 2 维问题。![z](https://cdn.cfd.direct/docs/user-guide-v9/img/user144x.png)因此，必须选择块在方向上的尺寸；这里选择 0.5 ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user145x.png) 。它不影响解，因为牵引边界条件被指定为应力而不是力，从而使解与横截面积无关。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user146x.png)

图 2.17：带孔板的网格块结构。 

用户应该切换到*运行*目录并将*plateHole*案例从$ *FOAM* *_TUTORIALS/stressAnalysis/solidDisplacementFoam*目录复制到其中。然后用户应该进入*plateHole*目录并在编辑器中打开*blockMeshDict*文件，如下所示

```c++
convertToMeters 1;

vertices
(
    (0.5 0 0)
    (1 0 0)
    (2 0 0)
    (2 0.707107 0)
    (0.707107 0.707107 0)
    (0.353553 0.353553 0)
    (2 2 0)
    (0.707107 2 0)
    (0 2 0)
    (0 1 0)
    (0 0.5 0)
    (0.5 0 0.5)
    (1 0 0.5)
    (2 0 0.5)
    (2 0.707107 0.5)
    (0.707107 0.707107 0.5)
    (0.353553 0.353553 0.5)
    (2 2 0.5)
    (0.707107 2 0.5)
    (0 2 0.5)
    (0 1 0.5)
    (0 0.5 0.5)
);

blocks
(
    hex (5 4 9 10 16 15 20 21) (10 10 1) simpleGrading (1 1 1)
    hex (0 1 4 5 11 12 15 16) (10 10 1) simpleGrading (1 1 1)
    hex (1 2 3 4 12 13 14 15) (20 10 1) simpleGrading (1 1 1)
    hex (4 3 6 7 15 14 17 18) (20 20 1) simpleGrading (1 1 1)
    hex (9 4 7 8 20 15 18 19) (10 20 1) simpleGrading (1 1 1)
);

edges
(
    arc 0 5 (0.469846 0.17101 0)
    arc 5 10 (0.17101 0.469846 0)
    arc 1 4 (0.939693 0.34202 0)
    arc 4 9 (0.34202 0.939693 0)
    arc 11 16 (0.469846 0.17101 0.5)
    arc 16 21 (0.17101 0.469846 0.5)
    arc 12 15 (0.939693 0.34202 0.5)
    arc 15 20 (0.34202 0.939693 0.5)
);

boundary
(
    left
    {
        type symmetryPlane;
        faces
        (
            (8 9 20 19)
            (9 10 21 20)
        );
    }
    right
    {
        type patch;
        faces
        (
            (2 3 14 13)
            (3 6 17 14)
        );
    }
    down
    {
        type symmetryPlane;
        faces
        (
            (0 1 12 11)
            (1 2 13 12)
        );
    }
    up
    {
        type patch;
        faces
        (
            (7 8 19 18)
            (6 7 18 17)
        );
    }
    hole
    {
        type patch;
        faces
        (
            (10 5 16 21)
            (5 0 11 16)
        );
    }
    frontAndBack
    {
        type empty;
        faces
        (
            (10 9 4 5)
            (5 4 1 0)
            (1 4 3 2)
            (4 7 6 3)
            (4 9 8 7)
            (21 16 15 20)
            (16 11 12 15)
            (12 13 14 15)
            (15 14 17 18)
            (15 18 19 20)
        );
    }
);

mergePatchPairs
(
);

// ************************************************************************* //
```

到目前为止，我们只在之前教程的几何图形中指定了直边，但在这里我们需要指定曲线边。这些在边关键字条目下指定，该条目是非直线边的列表。每个列表条目的语法以曲线的类型开头，包括arc、simpleSpline、polyLine*等 ，在第*[5.3.1](https://cfd.direct/openfoam/user-guide/v9-blockMesh#x26-1860005.3.1)节中进一步描述 。在此示例中，所有边都是圆形的，因此可以通过arc关键字条目指定。以下条目是圆弧的起点和终点的标签以及圆弧通过的点向量。

此*blockMeshDict中的块*并非所有人都具有相同的方向。如图 [2.17](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-4000117)![x2](https://cdn.cfd.direct/docs/user-guide-v9/img/user147x.png)所示，块 0 的方向![- x1](https://cdn.cfd.direct/docs/user-guide-v9/img/user148x.png)与块 4 的方向相同。这意味着在定义每个块中单元的数量和分布时必须小心，以便单元在块表面上匹配。

定义了 6 个面：板的每一侧一个，一个用于孔，一个用于前后平面。左面和下面都是对称平面。由于这是一个*几何*约束，它包含在*网格*的定义中，而不是纯粹的场边界条件规范。因此，它们使用特殊的 SymmetryPlane 类型来定义，*如*blockMeshDict*所示*。

frontAndBack面表示在 2D 情况下被忽略的平面。同样，这是一个几何约束，因此在网格中定义，使用*blockMeshDict*中所示的*空*类型。有关边界类型和几何约束的更多详细信息，用户应参阅第 [5.2](https://cfd.direct/openfoam/user-guide/v9-boundaries#x25-1770005.2)节。

其余面属于常规*面*类型。网格应该使用*blockMesh*生成，并且可以在*paraFoam*中查看，如第 [2.1.2](https://cfd.direct/openfoam/user-guide/v9-cavity#x5-110002.1.2)节所述。它应该如图 [2.18](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-4024418)所示。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user149x.png)

图 2.18：板中孔的网格问题。 

#### 2.2.1.1 边界条件和初始条件

网格生成完成后，必须设置具有边界条件的初始场。对于没有热应力的应力分析工况，只需设置位移D。*0/D*如下：

```c++
dimensions      [0 1 0 0 0 0 0];

internalField   uniform (0 0 0);

boundaryField
{
    left
    {
        type            symmetryPlane;
    }
    right
    {
        type            tractionDisplacement;
        traction        uniform (10000 0 0);
        pressure        uniform 0;
        value           uniform (0 0 0);
    }
    down
    {
        type            symmetryPlane;
    }
    up
    {
        type            tractionDisplacement;
        traction        uniform (0 0 0);
        pressure        uniform 0;
        value           uniform (0 0 0);
    }
    hole
    {
        type            tractionDisplacement;
        traction        uniform (0 0 0);
        pressure        uniform 0;
        value           uniform (0 0 0);
    }
    frontAndBack
    {
        type            empty;
    }
}

// ************************************************************************* //
```

首先，可以看出位移初始条件设置为![(0,0, 0)](https://cdn.cfd.direct/docs/user-guide-v9/img/user150x.png) ![米](https://cdn.cfd.direct/docs/user-guide-v9/img/user151x.png)。左面和下面的面片**必须**都是*symmetryPlane*类型，因为它们在*constant/多边形网格/边界*文件的网格描述中是这样指定的。同样，frontAndBack面被声明为*空*。

其他面是牵引边界条件，由专业*牵引*边界类型设置。牵引力边界条件由以下的线性组合指定：（1）关键字牵引力下的边界牵引力向量; (2) 在关键字压力下，产生垂直于边界表面的牵引力的压力，当指向表面外时定义为负值. 向上和孔面的牵引力为零，因此边界牵引力和压力设置为零。对于正确的面，牵引力应该是![(1e4,0, 0)](https://cdn.cfd.direct/docs/user-guide-v9/img/user152x.png) ![帕](https://cdn.cfd.direct/docs/user-guide-v9/img/user153x.png) ，压力应该是 0 ![帕](https://cdn.cfd.direct/docs/user-guide-v9/img/user154x.png)。

#### 2.2.1.2 机械性能

外壳的物理属性在*mechanicalProperties中设置**constant*目录中的字典。对于这个问题，我们需要指定表 [2.1](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-420031)中给出的钢的机械性能。在机械特性字典中，用户还必须将planeStress设置为yes。



| 财产     | 单位                                                         | 关键词 | 价值                                                         |
| -------- | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 密度     | ![    - 3公斤](https://cdn.cfd.direct/docs/user-guide-v9/img/user155x.png) | rho    | 7854                                                         |
| 杨氏模量 | ![帕](https://cdn.cfd.direct/docs/user-guide-v9/img/user154x.png) | 乙     | ![2×1011](https://cdn.cfd.direct/docs/user-guide-v9/img/user157x.png) |
| 泊松比   | —                                                            | 怒     | 0.3                                                          |
|          |                                                              |        |                                                              |

表 2.1：钢的机械性能

#### 2.2.1.3 热性能

温度场变量T存在于*solidDisplacementFoam中*求解器，因为用户可以选择通过生成的热应力求解与动量方程耦合的热方程。用户在运行时指定 OpenFOAM 是否应该通过*thermophysicalProperties中的*thermoStress开关求解热方程字典。该词典还设置了外壳的热特性，*例如表*[2.2](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-430052)中列出的钢 。



| 财产         | 单位                                                         | 关键词 | 价值                                                         |
| ------------ | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 比热容       | ![Ĵ](https://cdn.cfd.direct/docs/user-guide-v9/img/user158x.png)![  - 1 公斤](https://cdn.cfd.direct/docs/user-guide-v9/img/user159x.png)![  -1 千](https://cdn.cfd.direct/docs/user-guide-v9/img/user160x.png) | C      | 434                                                          |
| 导热系数     | ![W](https://cdn.cfd.direct/docs/user-guide-v9/img/user161x.png)![  -1米](https://cdn.cfd.direct/docs/user-guide-v9/img/user162x.png)![  -1 千](https://cdn.cfd.direct/docs/user-guide-v9/img/user163x.png) | ķ      | 60.5                                                         |
| 热膨胀系数。 | ![- 1千](https://cdn.cfd.direct/docs/user-guide-v9/img/user163x.png) | α      | ![        -5 1.1 × 10](https://cdn.cfd.direct/docs/user-guide-v9/img/user165x.png) |
|              |                                                              |        |                                                              |

表 2.2：钢的热性能

在这种情况下，我们不想求解热方程。因此，我们必须在thermophysicalProperties*中将*thermoStress关键字条目设置为no字典。

#### 2.2.1.4 控制

和之前一样，从*controlDict中读取与求解过程控制相关的信息*字典。对于这种情况，startTime是 0 ![s](https://cdn.cfd.direct/docs/user-guide-v9/img/user166x.png)。时间步长并不重要，因为这是一个稳态情况；在这种情况下，最好将时间步长deltaT设置为 1，这样它就可以作为稳态情况下的迭代计数器。endTime设置为 100，然后作为迭代次数的限制。writeInterval可以设置为![20](https://cdn.cfd.direct/docs/user-guide-v9/img/user167x.png)。

controlDict*条目*如下：

```c++

application     solidDisplacementFoam;

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         100;

deltaT          1;

writeControl    timeStep;

writeInterval   20;

purgeWrite      0;

writeFormat     ascii;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

graphFormat     raw;

runTimeModifiable true;


// ************************************************************************* //
```



#### 2.2.1.5 离散化方案和线性求解器控制

让我们将注意力转向*fvSchemes*字典。首先，我们正在分析的问题是稳态问题，因此用户应该为timeScheme中的时间导数选择SteadyState。这实质上关闭了时间导数项。并非所有求解器，尤其是流体动力学求解器，都适用于稳态和瞬态问题，但*solidDisplacementFoam*确实有效，因为这两种模拟的基本算法相同。

线弹性应力分析中的动量方程包括几个包含位移梯度的显式项。计算受益于梯度的准确和平滑评估。通常，在有限体积法中，离散化基于高斯定理。高斯方法对于大多数目的来说足够准确，但在这种情况下，最小二乘法将会被使用。因此，用户应该打开fvSchemes*系统*目录中的字典并确保最小平方为gradSchemes子词典中的grad(U)梯度离散方案选择方法：

```c++

d2dt2Schemes
{
    default         steadyState;
}

ddtSchemes
{
    default         Euler;
}

gradSchemes
{
    default         leastSquares;
    grad(D)         leastSquares;
    grad(T)         leastSquares;
}

divSchemes
{
    default         none;
    div(sigmaD)     Gauss linear;
}

laplacianSchemes
{
    default         none;
    laplacian(DD,D) Gauss linear corrected;
    laplacian(kappa,T) Gauss linear corrected;
}

interpolationSchemes
{
    default         linear;
}

snGradSchemes
{
    default         none;
}

// ************************************************************************* //
```

*系统*目录中的*fvSolution*字典控制解中使用的线性方程求解器和算法。用户应首先查看*求解器*子词典并注意求解器的选择对于D是GAMG. 求解器容差应该![10- 6](https://cdn.cfd.direct/docs/user-guide-v9/img/user168x.png)为这个问题设置。求解器相对容差，用relTol表示，设置每次迭代中残差所需的减少量。在每次迭代中设置严格（低）的相对容差是不经济的，因为每个方程中的许多项都是明确的，并且作为分离迭代过程的一部分进行更新。因此，相对公差的合理值是![0.01](https://cdn.cfd.direct/docs/user-guide-v9/img/user169x.png)，甚至可能更高，例如![0.1](https://cdn.cfd.direct/docs/user-guide-v9/img/user170x.png)，或者在某些情况下甚至![0.9](https://cdn.cfd.direct/docs/user-guide-v9/img/user171x.png)（如本例中）。

```c++

solvers
{
    "(D|T)"
    {
        solver          GAMG;
        tolerance       1e-06;
        relTol          0.9;
        smoother        GaussSeidel;
        nCellsInCoarsestLevel 20;
    }
}

stressAnalysis
{
    compactNormalStress yes;
    nCorrectors     1;
    D               1e-06;
}


// ************************************************************************* //
```

fvSolution字典包含一个子字典，*stressAnalysis ，**其中*包含一些特定于应用程序求解器的控制参数。首先有nCorrectors，它指定围绕完整方程组的外环的数量，包括*每个时间步内*的牵引边界条件。由于这个问题是稳态的，我们正在执行一组迭代，以实现收敛解，其中“时间步长”充当迭代计数器。因此，我们可以将nCorrectors设置为 1。

D关键字指定外部迭代循环的收敛容差，即*设置*初始残差水平，低于该水平求解将停止。![10-6](https://cdn.cfd.direct/docs/user-guide-v9/img/user172x.png)对于这个问题，它应该设置为之前指定的所需求解器容差。

### 2.2.2 运行代码

用户应该从下面指定的命令行在后台运行此处的代码，以便他/她之后可以查看日志文件中的收敛信息。

```sh
    solidDisplacementFoam > log &
```



用户应该通过查看生成的*日志*文件来检查收敛信息，该日志文件显示迭代次数以及正在求解的每个方向的位移的初始和最终残差。作为此迭代容差集，最终残差应始终小于初始残差的 0.9 倍。一旦两个初始残差都下降到![10- 6](https://cdn.cfd.direct/docs/user-guide-v9/img/user173x.png)运行的收敛容差以下，就已经收敛，可以通过终止批处理作业来停止。

### 2.2.3 后期处理

后处理可以按照第 [2.1.4](https://cfd.direct/openfoam/user-guide/v9-cavity#x5-130002.1.4)节进行。solidDisplacementFoam*求解*器将应力场输出![σ](https://cdn.cfd.direct/docs/user-guide-v9/img/user174x.png)为对称张量场sigma。这与 OpenFOAM 求解器中变量通常用数学符号表示的方式是一致的。在希腊符号的情况下，变量以语音命名。

对于后处理单个标量域组件*等* ![σxx](https://cdn.cfd.direct/docs/user-guide-v9/img/user175x.png)，可以通过运行*postProcess*实用程序来生成，如之前在 [2.1.5.7](https://cfd.direct/openfoam/user-guide/v9-cavity#x5-260002.1.5.7)节中，这次是在sigma上：![σxy](https://cdn.cfd.direct/docs/user-guide-v9/img/user176x.png)

```sh
    postProcess -func "components(sigma)"
```

名为sigmaxx、sigmaxy*等*的组件被写入案例的时间目录。![σxx](https://cdn.cfd.direct/docs/user-guide-v9/img/user177x.png)应力可以在*paraFoam*中查看， 如图 [2.19](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-4700119)所示。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user178x.png)

图 2.19：![σxx](https://cdn.cfd.direct/docs/user-guide-v9/img/user179x.png)带孔板中的应力场。 

我们想将方程 [2.14](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-39004r14)的解析解与我们的解进行比较。因此，我们必须输出一组![σxx](https://cdn.cfd.direct/docs/user-guide-v9/img/user180x.png)沿我们域的左边缘对称平面的数据。用户可以使用带有graphUniform函数的*postProcess*实用程序生成所需的图形数据。与之前不需要配置的*postProcess*示例不同，此示例包含一个预先配置在*系统*目录中的*graphUniform文件。*示例行设置在和之间，域在域列表中指定：![(0.0, 0.5,0.25)](https://cdn.cfd.direct/docs/user-guide-v9/img/user181x.png)![(0.0, 2.0,0.25)](https://cdn.cfd.direct/docs/user-guide-v9/img/user182x.png)

```c++
    Writes graph data for specified fields along a line, specified by start and
    end points.  A specified number of graph points are used, distributed
    uniformly along the line. 

\\*–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/

start           (0 0.5 0.25);
end             (0 2 0.25);
nPoints         100;

fields          (sigmaxx);

axis            y;

#includeEtc "caseDicts/postProcessing/graphs/graphUniform.cfg"

// ************************************************************************* //
```

用户应该使用graphUniform函数执行*postProcessing ：*

```sh
    postProcess -func graphUniform
```

数据以原始2 列格式写入*postProcessing/graphUniform*目录的 time 子目录中的文件中，*例如* s 处的数据在![t = 100](https://cdn.cfd.direct/docs/user-guide-v9/img/user183x.png) 文件*graphUniform/100/line* *_sigmaxx.xy*中找到。如果用户安装了*GnuPlot*，他们会启动它（通过输入gnuplot），然后绘制数值数据和解析解，如下所示：

```sh
    plot [0.5:2] [0:] "postProcessing/graphUniform/100/line_sigmaxx.xy",
        1e4*(1+(0.125/(x**2))+(0.09375/(x**4)))
```

[图2.20](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-4703620)显示了一个示例图 。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user184x.png)

图 2.20：沿垂直对称的法向应力![(σxx)x=0](https://cdn.cfd.direct/docs/user-guide-v9/img/user185x.png)

### 2.2.4 练习

用户可能希望通过尝试以下练习来试验*solidDisplacementFoam ：*

#### 2.2.4.1 提高网格分辨率

增加每个![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user186x.png)和![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user187x.png)方向的网格分辨率。使用*地图域*[将第2.2.3](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-470002.2.3)节的最终粗网格结果映射到 细网格的初始条件。

#### 2.2.4.2 引入网格分级

对网格进行分级，使靠近孔的单元比远离孔的单元更精细。设计网格，使相邻单元之间的大小比不超过 1.1，并且块之间的单元大小比与块内的比相似。网格分级在第 [2.1.6](https://cfd.direct/openfoam/user-guide/v9-cavity#x5-270002.1.6)节中描述。再次使用*mapFields将第*[2.2.3](https://cfd.direct/openfoam/user-guide/v9-plateHole/#x6-470002.2.3)节中的最终粗网格结果映射到 分级网格的初始条件。将结果与解析解和先前计算的结果进行比较。使用相同数量的单元格和不同的解决方案可以改进此解决方案吗？

#### 2.2.4.3 更改印版尺寸

解析解适用于一个无限大的板，其中有一个有限大小的孔。因此，对于有限尺寸的板，此解决方案并不完全准确。要估计误差，请增加板尺寸，同时将孔尺寸保持在相同的值。



## 2.3 破坏大坝



*在本教程中，我们将使用interFoam*解决二维简化的溃坝问题。该问题的特征是由尖锐界面或自由表面分隔的两种流体的瞬态流动. *interFoam*中的两相算法基于流体体积 (VOF) 方法，其中物质传输方程用于确定![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user188x.png)每个计算单元中两相的相对体积分数或相分数。物理特性根据该分数计算为加权平均值。VOF 方法的性质意味着物质之间的界面不是明确计算的，而是作为相分数场的属性出现的。由于相分数可以具有 0 和 1 之间的任何值，因此界面永远不会被明确定义，而是在应该存在尖锐界面的区域周围占据一个体积。

测试装置由位于水箱左侧膜后面的静止水柱组成。在时间![t = 0 秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user189x.png)，膜被移除并且水柱坍塌。在坍塌过程中，水会撞击水箱底部的障碍物并形成复杂的流动结构，包括几个捕获的空气袋。几何结构和初始设置如图 [2.21](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-5200521)所示。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user190x.png)

图 2.21：溃坝的几何形状。 

### 2.3.1 网格生成

用户应该进入他们的*运行*目录并从$ *FOAM* *_TUTORIALS/multiphase/interFoam/laminar/damBreak*目录中复制*damBreak案例，**即* 

```sh
    run
    cp -r $FOAM_TUTORIALS/multiphase/interFoam/laminar/damBreak/damBreak . 
```


进入*damBreak*案例目录并生成网格运行*blockMesh*，如前所述。damBreak网格由 5 个块组成*；*下面给出了*blockMeshDict*条目。

```c++
convertToMeters 0.146;

vertices
(
    (0 0 0)
    (2 0 0)
    (2.16438 0 0)
    (4 0 0)
    (0 0.32876 0)
    (2 0.32876 0)
    (2.16438 0.32876 0)
    (4 0.32876 0)
    (0 4 0)
    (2 4 0)
    (2.16438 4 0)
    (4 4 0)
    (0 0 0.1)
    (2 0 0.1)
    (2.16438 0 0.1)
    (4 0 0.1)
    (0 0.32876 0.1)
    (2 0.32876 0.1)
    (2.16438 0.32876 0.1)
    (4 0.32876 0.1)
    (0 4 0.1)
    (2 4 0.1)
    (2.16438 4 0.1)
    (4 4 0.1)
);

blocks
(
    hex (0 1 5 4 12 13 17 16) (23 8 1) simpleGrading (1 1 1)
    hex (2 3 7 6 14 15 19 18) (19 8 1) simpleGrading (1 1 1)
    hex (4 5 9 8 16 17 21 20) (23 42 1) simpleGrading (1 1 1)
    hex (5 6 10 9 17 18 22 21) (4 42 1) simpleGrading (1 1 1)
    hex (6 7 11 10 18 19 23 22) (19 42 1) simpleGrading (1 1 1)
);

edges
(
);

boundary
(
    leftWall
    {
        type wall;
        faces
        (
            (0 12 16 4)
            (4 16 20 8)
        );
    }
    rightWall
    {
        type wall;
        faces
        (
            (7 19 15 3)
            (11 23 19 7)
        );
    }
    lowerWall
    {
        type wall;
        faces
        (
            (0 1 13 12)
            (1 5 17 13)
            (5 6 18 17)
            (2 14 18 6)
            (2 3 15 14)
        );
    }
    atmosphere
    {
        type patch;
        faces
        (
            (8 20 21 9)
            (9 21 22 10)
            (10 22 23 11)
        );
    }
);

mergePatchPairs
(
);

// ************************************************************************* //
```



### 2.3.2 边界条件

用户可以通过查看*constant/polyMesh*目录下的*边界*文件来检查*blockMesh生成的边界几何。*该文件包含 5 个边界面的列表：leftWall、rightWall、lowerWall、大气和defaultFaces。用户应该注意面的类型。大气是一个标准*块*，即*没有*特殊属性，只是一个可以指定边界条件的实体。defaultFaces面*为*空因为面法线是在这个二维情况下我们不会解决的方向。leftWall 、rightWall和lowerWall面都是*一*面墙。

就像通用*面*一样，*墙壁*type 不包含有关网格的几何或拓扑信息，仅与普通*面*不同，它将面标识为墙壁，如果应用程序需要知道，*例如*应用特殊的墙壁表面建模。例如，*interFoam*求解器包括对表面张力的建模，并且可以包括在界面和壁表面之间的接触点处的壁粘附。壁粘附模型可以通过alpha ( ![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user188x.png)) 场上 的特殊边界条件应用，*例如* *constantAlphaContactAngle*边界条件，需要用户指定静态接触角theta0。

在本教程中，我们想忽略壁和界面之间的表面张力效应。我们可以通过设置静态接触角来做到这一点，![θ0 = 90∘](https://cdn.cfd.direct/docs/user-guide-v9/img/user192x.png)。*但是，可以将更简单的zeroGradient*应用于墙上的alpha，而不是使用*constantAlphaContactAngle*边界条件。

顶部边界对大气是自由的，因此需要根据内部流动允许流出和流入。因此，我们使用压力和速度的边界条件组合，在保持稳定性的同时做到这一点。他们是：

- *totalPressure*是一个*固定值*条件，由指定的总压力p0和局部速度U计算得出；
- *pressureInletOutletVelocity*，将*zeroGradient*应用于所有组件，但存在流入的情况除外，在这种情况下，将*fixedValue*条件应用于*切向*组件；
- *入口出口*， 向外流动时*为零梯度*  条件，*向内*流动时为固定值。

在所有壁面边界，*fixedFluxPressure*边界条件应用于压力场，它调整压力梯度，使边界通量与求解器的速度边界条件相匹配，包括重力和表面张力等体力。

代表 2D 问题的正面和背面的defaultFaces面，像往常一样，是一个*空*类型。

### 2.3.3 设置初始域

与前面的情况不同，我们现在将为相位分数指定一个非均匀的初始条件，![α水](https://cdn.cfd.direct/docs/user-guide-v9/img/user193x.png)其中

| ![        { α = 1 代表水相 水 0 代表空气相](https://cdn.cfd.direct/docs/user-guide-v9/img/user194x.png) | (2.15) |
| ------------------------------------------------------------ | ------ |
|                                                              |        |

这将通过运行*setFields来完成*效用。它需要一个位于*系统目录中的**setFieldsDict*字典，该案例的条目如下所示。

```c++

defaultFieldValues
(
    volScalarFieldValue alpha.water 0
);

regions
(
    boxToCell
    {
        box (0 0 -1) (0.1461 0.292 1);
        fieldValues
        (
            volScalarFieldValue alpha.water 1
        );
    }
);


// ************************************************************************* //
```

默认域值设置域的默认值，*即*域采用的值，除非在区域中另有指定子词典。该子词典包含一个包含fieldValues的子词典列表覆盖指定区域中的默认值。该区域基于一些拓扑约束创建一组点、单元或面。在这里，boxToCell在向量最小值和最大值内创建一个边界框，以定义水域的一组单元。该区域的相分数![α水](https://cdn.cfd.direct/docs/user-guide-v9/img/user195x.png)定义为 1。

*设置*域实用程序从文件中读取域，并在重新计算这些域后，将它们写回文件。在*damBreak*教程中，alpha.water域最初存储为名为alpha.water.orig的备份。当实际文件不存在时，会读取扩展名为.orig的域文件，因此*setFields*将读取alpha.water.orig但将结果输出写入alpha.water（或alpha.water.gz，如果打开压缩） . 这样原始文件不会被覆盖，因此可以重复使用。

因此，用户应该执行*setFields*像任何其他实用程序一样：

```sh
   setFields
```



使用*paraFoam*检查初始alpha.water场是否对应于图 [2.22](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-5505622)中所需的分布。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user196x.png)

图 2.22：相分数alpha.water的初始条件。 

### 2.3.4 流体特性

让我们检查一下*transportProperties**constant*目录中的文件。字典首先包含相中每个流体相的名称清单，这里是水和空气。然后将每种流体的材料属性分成两个字典*水*和*空气*。每个阶段的传输模型由transportModel关键字选择。用户应该选择牛顿在这种情况下，运动粘度是单值的，并在关键字nu下指定。其他模型的粘度参数，*例如* CrossPowerLaw，否则将按照第 [7.3](https://cfd.direct/openfoam/user-guide/v9-transport-rheology#x38-2860007.3)节中的说明进行指定。密度在关键字rho下指定。

两相之间的表面张力由关键字sigma指定. 本教程中使用的值列于表 [2.3](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-560113)中。



| 水属性     |                                                              |        |                                                              |
| ---------- | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 运动粘度   | ![平方米- 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user197x.png) | 怒     | ![1.0×10-6](https://cdn.cfd.direct/docs/user-guide-v9/img/user198x.png) |
| 密度       | ![公斤米 -3](https://cdn.cfd.direct/docs/user-guide-v9/img/user199x.png) | rho    | ![1.0×103](https://cdn.cfd.direct/docs/user-guide-v9/img/user200x.png) |
|            |                                                              |        |                                                              |
| 空气特性   |                                                              |        |                                                              |
| 运动粘度   | ![平方米- 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user201x.png) | 怒     | ![1.48 × 10 -5](https://cdn.cfd.direct/docs/user-guide-v9/img/user202x.png) |
| 密度       | ![公斤米 -3](https://cdn.cfd.direct/docs/user-guide-v9/img/user203x.png) | rho    | 1.0                                                          |
|            |                                                              |        |                                                              |
| 两相的性质 |                                                              |        |                                                              |
| 表面张力   | ![牛米 - 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user204x.png) | 西格玛 | 0.07                                                         |
|            |                                                              |        |                                                              |

表 2.3：*damBreak*教程的流体属性

重力加速度在整个域中是均匀的，并在名为*g的文件中指定*在*constant*目录中。与普通的域文件不同，*例如* *U*和*p*，*g*是一个*uniformDimensionedVectorField*，因此只包含一组维度和一个代表本教程的值：![(0,9.81,0) 毫秒- 2](https://cdn.cfd.direct/docs/user-guide-v9/img/user205x.png)

```c++

dimensions      [0 1 -2 0 0 0 0];
value           (0 -9.81 0);


// ************************************************************************* //
```



### 2.3.5 湍流建模

与空腔示例一样，湍流建模方法的选择可在运行时通过simulationType进行选择*动量传输*中的关键字字典。在这个例子中，我们希望在没有湍流建模的情况下运行，所以我们设置laminar：

```c++

simulationType  laminar;


// ************************************************************************* //
```



### 2.3.6 时间步长控制

时间步长控制是瞬态仿真和界面捕获求解器中的表面跟踪算法中的一个重要问题。Courant 数![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user206x.png)需要根据算法的选择进行限制：对于“显式”MULES 算法，![钴≈0.25](https://cdn.cfd.direct/docs/user-guide-v9/img/user207x.png)界面区域的稳定性上限是典型的；但使用 MULESCorr 指定的“半隐式” MULES*fvSolution*文件中的关键字，稳定性确实没有上限![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user208x.png)，而是根据时间精度的要求确定水平。

一般来说，很难指定一个固定的时间步长来满足![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user208x.png)标准，因此*interFoam*提供了时间步长的自动调整作为*controlDict*中的标准。用户应指定adjustTimeStep开启，相位场的最大值![公司](https://cdn.cfd.direct/docs/user-guide-v9/img/user208x.png)，maxAlphaCo, 和其他领域, maxCo, 为 1.0。时间步长maxDeltaT的上限可以设置为在此模拟中不会超过的值，*例如* 1.0。

通过使用自动时间步长控制，步长本身永远不会四舍五入到方便的值。因此，如果我们要求 OpenFOAM 以固定数量的时间步长间隔保存结果，则保存结果的时间有些随意。然而，即使使用自动时间步调整，OpenFOAM 也允许用户指定在固定时间写入结果；在这种情况下，OpenFOAM 强制自动时间步长程序调整时间步长，以便它“命中”为写入输出指定的确切时间。用户使用可调运行时间选择它writeControl的选项在*controlDict*字典中。控制*字典*字典条目应该是：

```c++

application     interFoam;

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         1;

deltaT          0.001;

writeControl    adjustableRunTime;

writeInterval   0.05;

purgeWrite      0;

writeFormat     binary;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable yes;

adjustTimeStep  yes;

maxCo           1;
maxAlphaCo      1;

maxDeltaT       1;


// ************************************************************************* //
```



### 2.3.7 离散化方案

*interFoam*求解器使用 Henry Weller 创建的用于显式求解的多维通用限制器( MULES) 方法，以保持相分数的有界性，独立于基础数值方案、网格结构*等。*因此，对流方案的选择不限于那些非常稳定或有界的，*例如*逆风差分.

对流方案设置在 fvSchemes 的*divSchemes*子字典中*进行*字典。在此示例中，动量方程 ( ![   ∙ ∇ (ρUU )](https://cdn.cfd.direct/docs/user-guide-v9/img/user211x.png)) 中的对流项（由div(rhoPhi,U)关键字表示）使用高斯 线性逆风梯度 (U)来产生良好的精度。在这里，我们选择了最佳稳定性![φ = 1.0](https://cdn.cfd.direct/docs/user-guide-v9/img/user212x.png)。由div(phi,alpha)关键字表示的![∇ ∙(U α)](https://cdn.cfd.direct/docs/user-guide-v9/img/user213x.png)术语使用专门的interfaceCompression方案，其中指定的系数是控制接口压缩的因素，其中： 0 对应于不压缩；1 对应保守压缩；并且，任何大于 1 的值都与接口的增强压缩有关。我们通常采用此示例中使用的值 1.0。

其他离散项使用常用方案，因此*fvSchemes*因此字典条目应该是：

```c++

ddtSchemes
{
    default         Euler;
}

gradSchemes
{
    default         Gauss linear;
}

divSchemes
{
    div(rhoPhi,U)  Gauss linearUpwind grad(U);
    div(phi,alpha)  Gauss interfaceCompression vanLeer 1;
    div(((rho*nuEff)*dev2(T(grad(U))))) Gauss linear;
}

laplacianSchemes
{
    default         Gauss linear corrected;
}

interpolationSchemes
{
    default         linear;
}

snGradSchemes
{
    default         corrected;
}


// ************************************************************************* //
```



### 2.3.8 线性求解器控制

在*fvSolution*文件中，求解器中的*alpha.water**子*字典包含特定于*interFoam*的元素。特别感兴趣的是nAlphaSubCycles和cAlpha关键字。nAlphaSubCycles![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user214x.png)表示方程中的子循环数；子循环是给定时间步长内方程的附加解。它用于在不减少时间步长和大幅增加求解时间的情况下使解稳定。这里我们指定 2 个子循环，这意味着![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user215x.png)方程![2×](https://cdn.cfd.direct/docs/user-guide-v9/img/user216x.png)在每个实际时间步内以半长时间步求解。

### 2.3.9 运行代码

代码的运行在之前的教程中有详细描述。尝试以下使用*tee*的命令，该命令可以将输出写入标准输出和文件：

```sh
    cd $FOAM_RUN/damBreak
    interFoam | tee log
```


代码现在将以交互方式运行，输出副本存储在*日志*文件中。

### 2.3.10 后期处理

现在可以以通常的方式对结果进行后处理。用户可以及时监测相组分α .[水](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-6200323)的发展， 如图 *2.23* 。



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user217x.png)（一）在 ![t = 0.25 秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user218x.png)。 



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user219x.png)(b) 在 ![t = 0.50 秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user220x.png)。 

图 2.23：阶段快照![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user221x.png)。 

### 2.3.11 并行运行

上一个示例的结果是使用相当粗糙的网格生成的。我们现在希望增加网格分辨率并重新运行该案例。新案例通常需要几个小时才能使用单个处理器运行，因此，如果用户可以访问多个处理器，我们可以展示 OpenFOAM 的并行处理能力。

用户应首先克隆*damBreak*案例，*例如*通过

```sh
    run
    foamCloneCase damBreak damBreakFine
```


进入新的案例目录，将*blockMeshDict*字典中的blocks描述修改为

```c++
    blocks
    (
        hex (0 1 5 4 12 13 17 16) (46 10 1) simpleGrading (1 1 1)
        hex (2 3 7 6 14 15 19 18) (40 10 1) simpleGrading (1 1 1)
        hex (4 5 9 8 16 17 21 20) (46 76 1) simpleGrading (1 2 1)
        hex (5 6 10 9 17 18 22 21) (4 76 1) simpleGrading (1 2 1)
        hex (6 7 11 10 18 19 23 22) (40 76 1) simpleGrading (1 2 1)
    );
```


在这里，条目显示为从*blockMeshDict*文件打印出来的；简而言之，用户必须更改网格密度，例如*46* 10 1条目，并将一些网格分级条目更改为1 2 1。字典正确后，通过运行*blockMesh*生成网格。

由于网格现在已从*damBreak*示例中更改，因此用户必须重新初始化*0时间目录中的相场*alpha.water，因为它包含许多与新网格不一致的元素。请注意，无需更改U和p _rgh域，因为它们被指定为统一的，与域中的元素数量无关。我们希望使用清晰的界面来初始化该域，*即*它的元素将具有或。*使用mapFields*更新域可能会在接口处产生插值，因此最好重新运行![α = 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user222x.png)![α = 0](https://cdn.cfd.direct/docs/user-guide-v9/img/user223x.png)![0 < α < 1](https://cdn.cfd.direct/docs/user-guide-v9/img/user224x.png)*setFields*实用程序。

网格大小现在与*0目录下的**alpha.water*文件中的元素数量不一致，因此用户必须删除该文件，以便使用原始的*alpha.water.orig*文件。

```sh
    rm 0/alpha.water
    setFields
```


OpenFOAM 使用的并行计算方法称为域分解，其中几何和相关的域被分解成小块并分配给单独的处理器进行求解。因此，运行并行案例所需的第一步是使用*decomposePar*实用程序分解域。有一个与*decomposePar*关联的字典，名为*decomposeParDict*，它位于教程案例的*系统目录中；*此外，与许多实用程序一样，可以在特定实用程序的源代码目录中找到默认字典，*即*在这种情况下位于$ *FOAM* *_UTILITIES/parallelProcessing/decomposePar*中。

第一个条目是numberOfSubdomains，它指定将案例分解成的子域的数量，通常对应于案例可用的处理器数量。

在本教程中，分解的方法应该是简单的，对应的simpleCoeffs应该根据以下标准进行编辑。域在和方向上被分割成片段或子域![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user225x.png)，每个方向上的子域数由向量 给出。由于此几何是二维的，因此第 3 个方向 ,不能被分割，因此必须等于 1。在和方向上分割域的和分量必须指定为使得 和 指定的子域的数量等于指定的numberOfSubdomains，![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user226x.png)![z](https://cdn.cfd.direct/docs/user-guide-v9/img/user227x.png)![n](https://cdn.cfd.direct/docs/user-guide-v9/img/user228x.png)![z](https://cdn.cfd.direct/docs/user-guide-v9/img/user227x.png)![新西兰](https://cdn.cfd.direct/docs/user-guide-v9/img/user230x.png)![恩克斯](https://cdn.cfd.direct/docs/user-guide-v9/img/user231x.png)![纽约](https://cdn.cfd.direct/docs/user-guide-v9/img/user232x.png)![n](https://cdn.cfd.direct/docs/user-guide-v9/img/user233x.png)![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user234x.png)![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user235x.png)![恩克斯](https://cdn.cfd.direct/docs/user-guide-v9/img/user236x.png)![纽约](https://cdn.cfd.direct/docs/user-guide-v9/img/user237x.png)*即* ![nxny =](https://cdn.cfd.direct/docs/user-guide-v9/img/user238x.png) numberOfSubdomains。将与子域相邻的单元面的数量保持在最低限度是有益的，因此，对于方形几何体，最好保持![X](https://cdn.cfd.direct/docs/user-guide-v9/img/user239x.png)和![是的](https://cdn.cfd.direct/docs/user-guide-v9/img/user240x.png)方向之间的分割应该相当均匀。delta关键字应设置为 0.001 。

例如，假设我们希望在 4 个处理器上运行。我们将numberOfSubdomains设置为 4 和![n = (2,2, 1)](https://cdn.cfd.direct/docs/user-guide-v9/img/user241x.png). 用户应使用以下命令运行*decomposePar*：

```sh
    decomposePar
```

终端输出显示分解在处理器之间均匀分布。

用户应参考第 [3.4](https://cfd.direct/openfoam/user-guide/v9-running-applications-parallel#x12-850003.4)节了解如何并行运行案例的详细信息；在本教程中，我们仅提供一个并行运行的示例。我们使用标准消息传递接口 (MPI) 的*openMPI*实现。作为这里的测试，用户可以在单个节点上并行运行，仅本地主机，通过键入：

```sh
    mpirun -np 4 interFoam -parallel > log &
```

用户可以通过创建一个文件来在网络上运行更多节点，该文件列出了要运行案例的机器的主机名，如第 [3.4.3](https://cfd.direct/openfoam/user-guide/v9-running-applications-parallel#x12-910003.4.3)节所述。该案例应该在后台运行，用户可以像往常一样通过监视*日志文件来跟踪其进度。*



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user242x.png)

图 2.24：并行处理情况下处理器 2 的网格。 



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user243x.png)（一）在 ![t = 0.25 秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user244x.png)。 



![img](https://cdn.cfd.direct/docs/user-guide-v9/img/user245x.png)(b) 在 ![t = 0.50 秒](https://cdn.cfd.direct/docs/user-guide-v9/img/user246x.png)。 

图 2.25：细化网格 的相位快照。![α](https://cdn.cfd.direct/docs/user-guide-v9/img/user247x.png)

### 2.3.12 后处理并行运行的案例

一旦案例完成运行，就可以使用*reconstructPar*实用程序重新组装分解的场和网格以进行后处理。只需从命令行执行它。细网格的结果如图 [2.25](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-6300425)所示。用户可以看到，与粗网格相比，界面的分辨率有了显着提高。

用户还可以通过简单地将单个处理器目录视为其自身的案例来单独对分解域的单个区域进行后处理。例如，如果用户通过以下方式启动*paraFoam*

```sh
    paraFoam -case processor1
```

然后*processor1*将作为一个案例模块出现在*ParaView*中。图 [2.24显示了使用](https://cfd.direct/openfoam/user-guide/v9-damBreak/#x7-6300124)简单方法分解域后来自处理器 1 的网格。



